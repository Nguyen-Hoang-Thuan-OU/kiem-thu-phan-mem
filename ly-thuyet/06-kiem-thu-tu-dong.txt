[NHỮNG CÁCH ĐỂ THỰC THI TEST CASE]

Để thực thi quá trình kiểm thử phần mềm:

	1. Thủ công (Manual): từ công đoạn lên kế hoạch, thiết kế kịch bản và thực thi đều sử dụng sức người.
		-> Con người tự nhập dữ liệu, nhấn nút, so sánh kết quả và kết luận.

	2. Tự động (Automation): con người chỉ tham gia vào công đoạn lên kế hoạch và thiết kế kịch bản, máy tính sẽ đảm nhận phần thực thi.
		-> Con người vết code để máy tính nhập dữ liệu, nhấn nút, so sánh kết quả và kết luận.

==========================================================================================

[ĐỊNH NGHĨA KIỂM THỬ TỰ ĐỘNG]

	* Kịch bản kiểm thử tự động (Test Script / Test Procedure): đoạn code được viết để tự động hoá quá trình kiểm thử, có thể độc lập với ngôn ngữ lập trình được sử dụng để tạo ra ứng dụng.

** Kiểm thử tự động (Automation/Automated Testing): con người sử dụng một ngôn ngữ lập trình và kết hợp thêm các phần mềm khác, công cụ, thư viện tự động hoá (framework)... để thiết kế sẵn kịch bản kiểm thử tự động (Test Script) và nhường lại phần thực thi dành cho máy tính.

	- Đôi khi sẽ có những kịch bản lặp lại nhiều lần đến mức gây nhàm chán, kém hiệu quả sau nhiều lần thực hiện, gây tốn thời gian và chi phí nếu con người tự thực hiện kiểm thử thủ công. Vì vậy, kiểm thử tự động được sinh ra để khắc phục những nhược điểm của kiểm thử thủ cộng.

	- Máy tính sẽ thay mặt con người tự động hoá việc thực thi các Test Case (tự động mở, nhập dữ liệu, nhấn nút, xem kết quả, tự so sánh và báo kết quả đúng sai thông qua email...).

	- Cách này cũng hiệu quả trong việc kiểm thử hồi quy (Regression Testing) vì một tính năng có thể được kiểm thử lại rất nhiều lần, đặc biệt là khi có một tính năng mới được tích hợp vào hoặc khi sửa chữa một tính năng cũ nào đó trong hệ thống.

	- Có thể thực thi kiểm thử tự động định kỳ theo một khung giờ cố định mà không cần đến sự can thiệp và giám sát của con người.

	-> Con người viết code để máy tính giả lập lại (tự động hóa) các hành động, cho phép máy tính thay con người thực hiện kiểm thử hệ thống và kết luận.

	Ví dụ 1: kiểm thử thủ công việc đăng nhập với 100 tài khoản khác nhau.
			-> Công việc lặp lại.
				=> Thiết kế kiểm thử tự động.

	Ví dụ 2: kiểm thử về đa ngôn ngữ trên một hệ thống.
			-> Đã hiểu quy trình kiểm thử thủ công.
				=> Thiết kế kiểm thử tự động.

--------------------------------------------------------------------------------

[CÁC CÁCH ĐỂ TỰ ĐỘNG HOÁ QUÁ TRÌNH KIỂM THỬ]

Có nhiều cách để viết kịch bản kiểm thử tự động (Test Script):
	- Code based / Script based: chủ động lập trình để tự động thực hiện các thao tác.
	- Keyword based / Action based: ghi hình lại các bước dạng kịch bản và tự động theo tác lại (Record & Replay / Playback), sau đó tự động tạo ra code để tuỳ ý chỉnh sửa tuỳ theo ngôn ngữ lập trình mong muốn.

==========================================================================================
==========================================================================================
==========================================================================================

[CÁC BƯỚC ĐỂ KIỂM THỬ TỰ ĐỘNG]

* Các bước cơ bản để kiểm thử tự động:
	01. Xác định các vùng/mục tiêu trong phần mềm để kiểm thử tự động (biết được mình đang cần kiểm thử cái gì).
	02. Chọn công cụ thích hợp để tự động hoá kiểm thử (sử dụng các công cụ, nền tảng và ngôn ngữ lập trình nào để kiểm thử API, UI, Mobile...).
	03. Lập trình/viết kịch bản kiểm thử (Test Script).
	04. Tạo ra tập hợp các trường hợp kiểm thử (Test Suite), kịch bản kiểm thử hoàn chỉnh (Test Scenario).
	05. Thực thi các kịch bản kiểm thử (Test Script).
	06. Ghi nhận lại kết quả và làm báo cáo.
	07. Phân tích để tìm lỗi hoặc vấn đề về hiệu năng.

==========================================================================================

[CÁC KỸ NĂNG CẦN CÓ ĐỂ KIỂM THỬ TỰ ĐỘNG]

* Danh sách các kỹ năng cần có:

	- Biết lập trình: cần có các kỹ năng về lập trình và ngôn ngữ lập trình để có thể viết được những kịch bản kiểm thử (Test Script) nhằm tự động hoá quá trình kiểm thử.
		+ Tuân thủ quy ước viết code.
		+ Sử dụng các công nghệ quản lý mã nguồn.

	- Rành về các Web element như XPath và CSS Selector: giúp nhận dạng đúng phần tử / đối tượng cần tương tác để tăng độ chính xác cho Test Script.

	- Thành thạo về một Automation Framework: sử dụng thành thạo thư viện của Selenium WebDriver API vì đây là thư viện được sử dụng phổ biến nhất trong việc kiểm thử ứng dụng web.

	- Thành thạo về một Testing Framework: hỗ trợ trong việc xây dựng framework, phân nhóm, quản lý Test Script, chuẩn bị dữ liệu, môi trường kiểm thử...

		+ Tìm hiểu về mẫu thiết kế phần mềm (Design Pattern): hỗ trợ thêm trong việc xây dựng framework.

	- Biết các câu lệnh truy vấn trong hệ quản trị cơ sở dữ liệu.

	- Hiểu biết về mô hình POM (Page - Object - Model).

	- ...

==========================================================================================

[NHỮNG LƯU Ý KHI KIỂM THỬ TỰ ĐỘNG]

* Nên áp dụng kiểm thử tự động cho:
	- Các dự án lớn và trọng điểm, những dự án dài hạn và tốn nguồn nhân lực.
	- Những dự án yêu cầu kiểm thử thường xuyên trong cùng một lĩnh vực (kiểm thử lặp lại một tính năng).
	- Những yêu cầu không thường xuyên thay đổi.
	- Kiểm thử hiệu năng (Performance Testing): giả lập nhiều người sử dụng cùng một lúc,...
	- Kiểm tra tính ổn định của phần mềm trên quan điểm của kiểm thử thủ công.
	- Tính khả dụng của thời gian.
	- So sánh những điểm ảnh (pixel), màu sắc... của hình ảnh.
	- So sánh những bảng tính (spreadsheets) với rất nhiều dòng và cột.
	- Chạy song song trên nhiều trình duyệt cùng một lúc.

------------------------------------------------------------

	* Ưu tiên áp dụng cho:
		+ Những Test Case passed (Positive).
		+ Test theo thứ tự, ví dụ: đăng ký > đăng nhập > tìm kiếm > chọn mua > thanh toán.
		+ Kiểm thử giao diện (UI): phân trang, ô nhập, nút nhấn...
		+ Kiểm thử hiệu năng (Performance Testing).

--------------------------------------------------------------------------------

* Lưu ý khi lựa chọn kiểm thử tự động:
	- Chi phí khởi đầu (thuê nhân viên, mua công cụ...) cho kiểm thử tự động rất cao.
	- Kiểm thử tự động không phải là 100%, có một số trường hợp không thể kiểm thử tự động.
	- Không kiểm thử tự động với trường hợp UI không cố định.
	- Người kiểm thử tự động nên có kiến thức lập trình tốt.

==========================================================================================

[ƯU VÀ NHƯỢC ĐIỂM CỦA KIỂM THỬ TỰ ĐỘNG]

* Ưu điểm:
	- Cải thiện hiệu quả: nhanh hơn kiểm thử thủ công.
	- Cải thiện độ chính xác: đáng tin cậy hơn con người do bộ dữ liệu kiểm thử đã được chuẩn bị từ trước và đã qua quá trình kiểm tra trước khi đưa vào tự động.
	- Tính tái sử dụng cao: nếu xây dựng được một bộ framework cho riêng mình thì có thể tái sử dụng trong nhiều dự án có cùng cấu trúc (thường do một công ty thiết kế dựa trên một mẫu sẵn có).
	- Tiết kiệm được thời gian: có thể hoạt động 24/24 trong khi con người chỉ có thể bằng 50% hoặc 33% về thời gian hoạt động.
	- Hỗ trợ thực thi Các Test Case một cách lặp lại: có thể được thực hiện lại nhiều lần trên các loại trình duyệt khác nhau.

--------------------------------------------------------------------------------

* Nhược điểm:
	- Tốn chi phí để trả cho các công cụ tự động hoá chuyên nghiệp (phí bản quyền) và thuê nhân viên có am hiểu về kiểm thử tự động, tốn phí quản lý và bảo trì, tìm hiểu, huấn luyện / đào tạo / giáo dục...
	- Mất thời gian, công sức để tạo mới và chỉnh sửa Test Script.
	- Không phải trường hợp nào cũng phù hợp để kiểm thử tự động.
		Ví dụ: kiểm tra độ đẹp / xấu của UI...

==========================================================================================

[NHỮNG TEST CASE NÀO NÊN VÀ KHÔNG NÊN KIỂM THỬ TỰ ĐỘNG]

* Những Test Case có thể kiểm thử tự động:
	- Rủi ro cao - các Test Case quan trọng.
	- Những Test Case được thực hiện nhiều lần.
	- Những Test Case khó thực hiện thủ công.
	- Những Test Case tốn thời gian của con người.

--------------------------------------------------------------------------------

* Những Test Case không phù hợp để kiểm thử tự động:
	- Những Test Case được thiết kế mới và chưa được thực hiện thủ công ít nhất một lần.
	- Những Test Case có các yêu cầu thường xuyên thay đổi (do khách hàng chưa quyết định được tính năng, hay thay đổi yêu cầu phần mềm,...).
	- Những Test Case được thực hiện đột xuất, không có kế hoạch, kịch bản hay tài liệu tham khảo (ad-hoc). Có những Test Case khi thực thi chỉ để tạm thời giải quyết ngay vào lúc xảy ra vấn đề, không thể tổng quát hoá và tối ưu hoá thành một phương thức để áp dụng về sau này (Random/Monkey Testing).
	- Những Test Case liên tục failed.
	- Những hệ thống áp dụng quá nhiều thiết kế đồ hoạ (hiệu ứng).

==========================================================================================
==========================================================================================
==========================================================================================

[CÁCH THIẾT KẾ KỊCH BẢN KIỂM THỬ TỰ ĐỘNG - TEST SCRIPT]

** Có nhiều cách để viết kịch bản kiểm thử tự động (Test Script):

	1. Code based / Script based: chủ động lập trình bằng cách sử dụng Selenium, WebDriver và kiến thức lập trình hướng đối tượng (OOP) để viết Test Script (Page Object Model - POM) và tự động thực hiện các thao tác.
		-> Sử dụng thư viện lập trình Selenium và ngôn ngữ lập trình.

	2. Keyword based / Action based: ghi hình lại các bước dạng kịch bản (Linear: Record & Replay / Playback) bằng một phần mềm đã được viết sẵn chuyên phục vụ cho việc ghi hình các bước (không phải ghi màn hình dạng video), để tự động hoá thao tác thực thi các Test Case ở mức cơ bản.

		- Sau khi ghi hình xong, sẽ in ra một tập các bước đã thực hiện và cho phép can thiệp, chỉnh sửa lại các bước. Có thể chuyển thành ngôn ngữ lập trình (Java, C#, Python,...) và cho phép chỉnh sửa lại theo phong cách lập trình nếu cần thiết.

		-> Sử dụng công cụ đồ hoạ Selenium IDE.
		-> Sử dụng công cụ record + code: Katalon...

==========================================================================================

[CÁC CÔNG CỤ KIỂM THỬ TỰ ĐỘNG - TEST AUTOMATION FRAMEWORKS]

** Các công cụ hỗ trợ kiểm thử tự động hai trong một - Studio (Functional Automation Testing Tools): Katalon, Telerik, Ranorex, TestComplete, Watir, HP QTP/UFT (Quick Test Professional/Unified Functional Testing)...

	- Dựa trên framework kiểm thử tự động mã nguồn mở (test automation framework) Selenium (web), Appium (desktop, mobile)...
		+ Selenium giống như một bộ thư viện, chuyên cung cấp sẵn các hàm để hỗ trợ trong việc bắt các thành phần (component) trên trang web duyệt theo cấu trúc cây DOM.

	- Sử dụng phần lõi của các thư viện thuần lập trình, nhưng sau đó đóng gói các hàm đã được làm sẵn của thư viện lại thành một ứng dụng để tiện cho việc sử dụng.

	- Lưu lại các phần tử website dưới dạng đối tượng trong Element Repository (Object Repository) và cho phép tái sử dụng trong các Test Case khác nhau của cùng một dự án.

==========================================================================================

[SELENIUM - BỘ ĐỒ NGHỀ ĐA NĂNG]

Không chỉ là một công cụ đơn lẻ, Selenium là cả một "bộ đồ nghề" (Suite / Set) với một loạt công cụ phần mềm (và thư viện) khác nhau, mỗi công cụ sẽ có những cách tiếp cận khác nhau để hỗ trợ tự động hóa trình duyệt.

	- WebDriver giống như Interface và Selenium implements các tiêu chuẩn về giao thức WebDriver của W3C.

	- Giúp tự động mô phỏng lại những hành vi của người dùng bằng cách định vị và tương tác với các thẻ / phần tử / thành phần (tag / element / component) trong trình duyệt.

	- Mục đích chính là để phục vụ việc kiểm thử tự động cho những ứng dụng web. Nhưng rộng hơn là bất kì tác vụ nào trên nền web.

--------------------------------------------------------------------------------

	[LỊCH SỬ HÌNH THÀNH - SELENIUM HISTORY]

Với tên gọi ban đầu là JavaScriptTestRunner, Selenium được phát triển bởi Jason Huggins vào năm 2004 khi ông đang làm lập trình viên tại ThoughtWorks, mục đích ban đầu của ông là phát triển một thư viện Javascript để chạy tự động các test trên nhiều trình duyệt.

Năm 2006, Simon Stewart - một nhân viên của Google tiếp tục phát triển Selenium với công việc được đặt tên là WebDriver. Nhờ có công cụ này, Google đã nhận được một lượng người sử dụng Selenium rất lớn nhưng đứng trước những hạn chế của sản phẩm thì các tester vẫn phải làm việc rất vất vả.

Năm 2008, Selenium và WebDriver chính thức được kết hợp bởi Selenium đang dần lớn mạnh và WebDriver lại là công cụ của tương lai. Với sự kết hợp này, người dùng được cung cấp một tệp những tính năng lớn.

Cái tên Selenium xuất hiện từ một trò đùa của Huggins dành cho Mercury (công ty đã từng tạo ra một framework thử nghiệm phổ biến hơn khi Selenium đang trong quá trình phát triển) - đối thủ cạnh tranh của mình.

* Tham khảo thêm:
	- https://www.selenium.dev/history/
	- https://viettuts.vn/selenium

--------------------------------------------------------------------------------

	[HỆ SINH THÁI - SELENIUM ECOSYSTEM]

Trong hơn 10 năm qua, một hệ sinh thái gồm nhiều dự án mã nguồn mở đã được xây dựng để phục vụ cho Selenium và lấy Selenium WebDriver làm trọng tâm.

------------------------------------------------------------

		[TRÌNH DUYỆT HỖ TRỢ - BROWSERS]

		Có thể hoạt động được trên nhiều trình duyệt khác nhau với những WebDriver tương ứng:

			1. Firefox: Mozilla GeckoDriver
			2. Edge: Microsoft EdgeDriver
			3. Chrome: Google ChromeDriver
			4. Opera: Opera ChromiumDriver
			5. Safari: Apple SafariDriver
			6. Internet Explorer: InternetExplorerDriver

------------------------------------------------------------

		[NGÔN NGỮ LẬP TRÌNH - LANGUAGE BINDINGS]

		Cần sử dụng một ngôn ngữ lập trình để có thể tạo ra các kịch bản (script) nhằm tương tác với Selenium Server (Remote WebDriver) hoặc tương tác với Selenium WebDriver dưới cục bộ.

			01. C#
			02. Java
			03. Python
			04. JavaScript
			05. Ruby

			06. Go
			07. Haskell
			08. Perl
			09. PHP
			10. R
			11. Dart
			12. Pharo Smalltalk

------------------------------------------------------------

		[HỆ ĐIỀU HÀNH - OPERATING SYSTEMS]

		Có thể hoạt động được trên nhiều hệ điều hành khác nhau:

			1. Microsoft Windows: tuy chỉ sử dụng những phiên bản mới nhất của hệ điều hành Windows để kiểm thử và sửa lỗi cho dự án Selenium, nhưng miễn là phiên bản của Windows còn được Microsoft hỗ trợ, thì chắc chắn sẽ sử dụng được Selenium.

			2. macOS: dù dạo gần đây không từng sử dụng bất kỳ phiên bản nào của macOS để kiểm thử cho dự án Selenium, nhưng vẫn có hỗ trợ phiên bản ổn định và thường không phải là phiên bản mới nhất.

			3. Linux: Ubuntu là nền tảng kiểm thử chính của dự án Selenium, nhưng những biến thể khác của Linux vẫn sẽ hoạt động tốt miễn là các nhà phát hành trình duyệt còn hỗ trợ.

------------------------------------------------------------

		[FRAMEWORKS]

		Programming languages are supported through Selenium drivers. These are libraries made for each language that expose commands from the Selenium API natively in the form of methods/functions.

		Selenium is often used for automating web applications for testing purposes, but it does not include a testing framework. Some testing frameworks that can be used with Selenium are listed below.

			- Ruby:
				+ Watir
				+ Capybara

			- JavaScript:
				+ WebdriverIO
				+ CodeceptJS
				+ Nightwatch.js

			- Java:
				+ FluentLenium
				+ QAF
				+ Selenide

			- Python:
				+ Helium
				+ Nerodia
				+ SeleniumBase

--------------------------------------------------------------------------------

	[CÁC THÀNH PHẦN - SELENIUM COMPONENTS]

* Tham khảo thêm: https://www.selenium.dev/documentation/overview/components/

--------------------------------------------------------------------------------

	[CÁC DỰ ÁN SELENIUM - SELENIUM PROJECT]

Là một "bộ sưu tập đồ nghề" với nhiều công cụ khác nhau, mỗi công cụ sẽ đáp ứng từng nhu cầu kiểm thử khác nhau. Là sự kết hợp của nhiều dự án khác nhau để tạo thành một hệ thống kiểm thử đa năng.

* Bộ đồ nghề Selenium (Selenium Suite) bao gồm:

------------------------------------------------------------

	1. Selenium IDE: với tên cũ là Selenium Recorder và được ra mắt vào năm 2006. Đây là một tiện ích mở rộng (Plug-in / Add-on / Extension) sử dụng trên trình duyệt Chrome, Firefox và Edge. Hỗ trợ ghi hình lại các bước dạng kịch bản (Record & Replay / Playback) và quản lý theo bộ (Suite), giúp tự động mô phỏng lại những thao tác của người dùng trên trình duyệt. Thường được sử dụng để tạo ra những đoạn kịch bản (Selenium Script) đơn giản hoặc để kiểm thử thăm dò (Exploratory Testing) mà không cần phải có quá nhiều kiến thức về lập trình.
		-> Tiện ích mở rộng trên trình duyệt, giúp ghi hình lại các bước dạng kịch bản.

		* Selenese / Selenium command: là ngôn ngữ miền chuyên biệt / ngôn ngữ đặc tả chuyên biệt (Domain-specific language - DSL) của Selenium IDE. Selenese cung cấp một tập hợp gồm nhiều câu lệnh (Action, Accessor và Assertion), được sử dụng tự động hoá các tương tác trên web. 
	-> Ngôn ngữ đặc biệt để viết Test Script của Selenium IDE.

			(* Tham khảo thêm: https://www.selenium.dev/documentation/legacy/selenium_ide/#selenium-commands--selenese)

------------------------------------------------------------

	2. Selenium RC (Remote Control) / (Selenium 1): phiên bản đầu tiên của Selenium, được ra mắt vào năm 2004. Selenium Remote Control (RC) là một Server ảo được viết bằng Java, làm trung gian giao tiếp giữa người dùng và trình duyệt bằng cách nhận các câu lệnh, phiên dịch và báo cáo kết quả của việc thực thi.
		-> Sử dụng ngôn ngữ lập trình để điều khiển trình duyệt, Selenium Remote Control sẽ làm Server ảo trung gian.

------------------------------------------------------------

	3. Selenium WebDriver - 2/3/4: phiên bản nâng cấp của Selenium RC (hợp nhất Selenium RC và Selenium WebDriver), ra mắt vào năm 2008. Phần lõi (core) của Selenium chính là Selenium WebDriver. Là một interface và cho phép người dùng viết code để làm việc trực tiếp với trình duyệt ở mức độ hệ điều hành mà không cần đến Server ảo nữa.
		-> Sử dụng ngôn ngữ lập trình để điều khiển trình duyệt, tương tác trực tiếp mà không cần thông qua Server ảo.

------------------------------------------------------------

	4. Selenium Grid: Selenium Hub là tính năng dùng để chạy Test Script một cách phân tán và song song trên nhiều máy tính - WebDriver node (khi cần chạy Test Script trên nhiều hệ điều hành, trình duyệt / phiên bản của trình duyệt...) mà không cần phải chỉnh sửa lại Test Script, đã được code sẵn trong Selenium, chỉ việc lấy và sử dụng.
		-> Chạy Test Script cùng một lúc trên nhiều tổ hợp máy, hệ điều hành, trình duyệt và phiên bản khác nhau.
		(* Tham khảo thêm: https://vananhtooo.wordpress.com/2017/09/26/selenium-grid-la-gi/)

(* Tham khảo thêm: https://en.wikipedia.org/wiki/Selenium_(software))

--------------------------------------------------------------------------------

	[TÓM TẮT VỀ SELENIUM]

* Tóm tắt về Selenium:
	- Là một dự án ô mã nguồn mở.
	- Chuyên được sử dụng để tự động hoá kiểm thử cho ứng dụng web.
	- Hoạt động được trên nhiều trình duyệt và nền tảng: Microsoft Windows, macOS, Linux.
	- Hỗ trợ nhiều ngôn ngữ lập trình: C#, Java, Python, JavaScript, Ruby...

Tuỳ thuộc vào ngữ cảnh mà Selenium có thể là:
	- Công cụ. (chính thống, chỉ phục vụ cho nền tảng web)
	- Framework.
	- Thư viện. (có thể được import vào trong một project để sử dụng)

==========================================================================================

[SỬ DỤNG WEBDRIVER ĐỂ THIẾT KẾ KỊCH BẢN KIỂM THỬ TỰ ĐỘNG]

Có nhiều hãng thiết kế trình duyệt web với những trình duyệt khác nhau (Mozilla, Google, Apple, Microsoft...), nhưng tất cả đều tuân thủ và thiết kế theo tiêu chuẩn do W3C đã đưa ra, từ đó giúp dễ dàng hơn trong việc tương thích.
	* W3C (World Wide Web Consortium): tổ chức tiêu chuẩn quốc tế chính cho World Wide Web. Hiệp hội này chuyên đề xuất các tiêu chuẩn cho World Wide Web, giúp chuẩn hoá các khái niệm liên quan đến web.

	Ví dụ: để cạnh tranh, các trình duyệt khác nhau quyết định hỗ trợ những bộ thẻ khác nhau, gây khó khăn cho các lập trình viên, khiến một số website chỉ hoạt động tốt ở một số trình duyệt nhất định.
		-> Chuẩn hoá và thống nhất.

Mặc định, trình duyệt sẽ được người dùng điều khiển thông qua các ô nhập, nút nhấn, mở tab mới, lưu dấu trang, xoá dữ liệu duyệt web... Nhưng trong bộ tiêu chuẩn khi thiết kế trình duyệt có một tiêu chuẩn nói rằng: "mọi trình duyệt nên cho phép lập trình viên điều khiển được hoạt động của trình duyệt thông qua code", để giúp cho QC tự động hoá quá trình kiểm thử website dưới góc nhìn của người dùng.

Lúc này, trình duyệt chính là một đối tượng (object), cung cấp các hàm cho các lập trình viên và cho phép tương tác thông qua việc gọi hàm.

	-> Cho phép code đóng vai người dùng để sử dụng trình duyệt.

------------------------------------------------------------

* Tham khảo thêm:
	- https://w3c.github.io/webdriver/
	- https://www.w3.org/TR/webdriver/

--------------------------------------------------------------------------------

[ĐIỀU KHIỂN TRÌNH DUYỆT BẰNG NGÔN NGỮ LẬP TRÌNH]

** Quy trình viết kịch bản kiểm thử tự động bằng việc chủ động lập trình:

	Python			Selenium		GeckoDriver		FireFox
	Java			client			ChromeDriver		Chrome
	C#			library			SafariDriver		Safari


								  HTTP over HTTP Server
								-------------------------
								|			|
								|			v
| Ngôn ngữ lập trình |--->| Thư viện lập trình |--->| Browser WebDriver |--->| Trình duyệt |
								^			|
								|			|
			    JSON Wire Protocol			-------------------------
			    Over HTTP				  HTTP over HTTP Server
			 (Không còn được sử dụng
			  ở Selenium 4)


// Có thể hình dung:
						JDBC, ADO.NET			Database Engine: SQL Server,
				(Vừa kết nối với Database Engine,				 Oracle, MySQL
			vừa cung cấp bộ thư viện để giao tiếp với Driver)

--------------------------------------------------------------------------------

[NHỮNG CÔNG CỤ CẦN PHẢI CÓ]

Đối với người dùng, việc tương tác với trình duyệt sẽ chỉ đơn giản là thông qua giao diện, vì trình duyệt được thiết kế để họ dễ dàng sử dụng. Nhưng đối với các kiểm thử viên tự động (Automation Tester), với nhu cầu kiểm thử một ứng dụng web, để tương tác và điều khiển được trình duyệt thông qua ngôn ngữ lập trình, thì phải sử dụng thêm cầu nối trung gian (trình điều khiển - driver - thư viện), giúp giao tiếp với trình duyệt thật sự.

------------------------------------------------------------

	[1. BỘ THƯ VIỆN LẬP TRÌNH - SELENIUM AUTOMATION FRAMEWORK]

	* Client library / Client library API: cung cấp API để giao tiếp giữa ngôn ngữ lập trình và WebDriver.
		- Cho phép sử dụng ngôn ngữ lập trình để chạy các lệnh Selenium bằng cách cung cấp một loạt các hàm thông qua API.
		- Mỗi ngôn ngữ lập trình khác nhau sẽ có gói thư viện khác nhau.
		- Có nhiệm vụ nhận các câu lệnh và đưa sang cho Selenium Server để tiến hành kiểm thử, đồng thời cũng sẽ nhận các kết quả trả về và trả về cho ứng dụng. Ứng dụng sẽ lưu kết quả xử lý vào một biến và kiểm tra xem thành công hay thất bại.

----------------------------------------

** Thư viện lập trình (Selenium): để điều khiển được trình duyệt thì bắt buộc phải sử dụng code, kèm theo đó là những thư viện được gói trong package / namespace.

	- Trong ngữ cảnh này sẽ là Selenium WebDriver.

	- Tập hợp gồm nhiều lớp (class) với các phương thức / hàm được đóng gói theo một định dạng cụ thể (*.jar, *.dll, *.exe...), nhằm cung cấp các lệnh (API) để lập trình viên kết nối với WebDriver. Vì đã là thư viện nên cách sử dụng cũng sẽ giống hệt như mọi thư viện khác trong ngôn ngữ lập trình.

	- Khi chạy Test Script, Selenium WebDriver sẽ gọi trực tiếp (direct call) cho trình duyệt thông qua chính trình điều khiển mà trình duyệt đấy cung cấp. Sau đó, các hành động trong Test Script sẽ được thực thi.

		* Chi tiết lời gọi trực tiếp (direct call):

			1. Với mỗi một hành động từ Test Script, một thông điệp HTTP Request sẽ được tạo ra để gửi các yêu cầu từ Client lên Server.

			2. HTTP Request đó sẽ được gửi đến Browser WebDriver.

			3. Mỗi Browser WebDriver sẽ có một HTTP Server để tiếp nhận HTTP request.

			4. Sau khi nhận được thông điệp, HTTP Server xác định những bước cần thiết để thực thi hành động phản hồi lại yêu cầu.

			5. HTTP Server mô phỏng lại các thao tác theo đúng những bước đã được thiết kế trong Test Script.

			6. Sau đó, HTTP Server trả lại trạng thái thực hiện những hành động cho Client, nơi đang thực thi Test Script.

------------------------------------------------------------

	[2. TRÌNH ĐIỀU KHIỂN TRÌNH DUYỆT - BROWSER WEBDRIVER / PROXY]

** Trình điều khiển trình duyệt (Browser WebDriver): vì theo quy chuẩn của W3C thì trình duyệt phải được thiết kế mở, đi kèm với trình duyệt sẽ là một "người anh em song sinh", rất am hiểu vể trình duyêt nên có thể điều khiển được trình duyệt.

	- Bản thân trình duyệt là một thế giới riêng và rất phức tạp, con người không thể can thiệp trực tiếp thông qua code được. Cũng để đảm bảo tính trừu tượng (abstraction) của việc thiết kế mà những thư viện lập trình (Selenium) không được trực tiếp can thiệp vào trình duyệt, vì vậy WebDriver sẽ làm cầu nối trung gian và đảm nhận việc tương tác giữa trình duyệt và thư viện lập trình (Selenium).

	- WebDriver là một ứng dụng / trình điều khiển / cầu nối trung gian (giống như Proxy) để kết nối giữa trình duyệt và thư viện lập trình. Bao gồm: ChromeDriver, OperaDriver, GeckoDriver... Đại diện cho một đối tượng (object) trình duyệt và cung cấp các lệnh / hàm để lập trình viên có thể sử dụng.

	- Bộ quy chuẩn chung được tách riêng cho khỏi trình duyệt. Là đoạn code chạy song song với trình duyệt, có kết nối với thư viện lập trình (Selenium), từ đó cho phép ngôn ngữ lập trình (Python, Java, C#...) can thiệp vào trình duyệt để kiểm thử những ứng dụng web một cách tự động bằng code.

	-> Tập tin nhị phân biết cách giao tiếp với trình duyệt và thư viện lập trình.

(* Tham khảo thêm: https://www.selenium.dev/documentation/webdriver/)

------------------------------------------------------------

	[3. TRÌNH DUYỆT - BROWSER]

** Trình duyệt (Browser): giúp đưa con người đến mọi nơi trên internet, cho phép họ xem văn bản, hình ảnh và video từ mọi nơi trên thế giới.

==========================================================================================

[CÁC BƯỚC CƠ BẢN CẦN THỰC HIỆN ĐỂ THIẾT KẾ KỊCH BẢN KIỂM THỬ TỰ ĐỘNG]

** Các yêu cầu để viết kịch bản kiểm thử (Test Script):

	1. Thư viện lập trình (Selenium Automation Framework): Selenium (tuỳ vào ngôn ngữ lập trình).

	2. Trình điều khiển trình duyệt (WebDriver): phần trung gian để kết nối với trình duyệt, thay con người điều khiển trình duyệt. Tuỳ vào trình duyệt và phiên bản của trình duyệt đang sử dụng, mà có thể chọn phiên bản phù hợp cho trình điều khiển.

	3. Trình duyệt (Browser): nên có thể chọn những trình duyệt ít phát hành phiên bản cập nhật (ví dụ: Firefox...). Vì những phiên khác nhau của cùng một trình duyệt đã có thể khác nhau về câu lệnh, nên yêu cầu phải có sự tương thích giữa những phiên bản của trình duyệt và trình điều khiển trình duyệ.

(* Tham khảo thêm: https://www.selenium.dev/documentation/webdriver/getting_started/install_library/)

--------------------------------------------------------------------------------

	[THIẾT KẾ KỊCH BẢN KIỂM THỬ VỚI SELENIUM WEBDRIVER]

	(Trên hệ điều hành Windows
	 với ngôn ngữ lập trình Java & Python,
	 sử dụng trình duyệt Google Chrome / Chromium - Lõi - Kernel)

** Các bước viết code (Test Script) để tự động hoá những thao tác của QC / Người dùng khi sử dụng một website (điều khiển trình duyệt) bằng Selenium WebDriver:

------------------------------------------------------------

	Bước 00: Tải và đảm bảo trình duyệt đã được cài ở đường dẫn mặc định (C:\Program Files\Google\Chrome\Application\).
		- Có thể kiểm tra bằng cách gõ trực tiếp đường dẫn "chrome://version/" vào trình duyệt.

		- Nếu không cài ở đường dẫn mặc định, ta vẫn có thể yêu cầu ChromeDriver sử dụng đường dẫn tuỳ chọn: https://chromedriver.chromium.org/capabilities

------------------------------------------------------------

	Bước 01: Kiểm tra phiên bản hiện tại của trình duyệt và sau đó tải xuống ChromeDriver (tập tin nhị phân *.exe) tương ứng với phiên bản đang sử dụng.

		1. Kiểm tra phiên bản của trình duyệt:
			Help -> About Google Chrome
			(Hoặc sử dụng: chrome://version/)

		2. Tải phiên bản ChromeDriver tương ứng với phiên bản hiện tại của trình duyệt.
			- https://chromedriver.chromium.org/downloads
			- https://chromedriver.storage.googleapis.com/index.html

------------------------------------------------------------

	Bước 02: Tải thư viện Selenium và những thư viện phụ thuộc đi kèm khác tương ứng với ngôn ngữ lập trình.

		- Java:
			+ Ant: https://github.com/SeleniumHQ/selenium/releases/
			+ Maven: https://mvnrepository.com/artifact/org.seleniumhq.selenium/selenium-java

			// Có thể chỉ cần tải riêng mỗi thư viện Selenium API

------------------------------------------------------------

	Bước 03: Tạo mới một dự án và sao chép tập tin ChromeDriver.exe vào trong cùng thư mục chứa code hoặc môi trường ảo (venv - python), để dễ quản lý khi đưa lên Server (ví dụ: GitBub...) và sử dụng mà không cần khai báo đường dẫn quá dài, nếu để ở nơi khác thì phải chỉ rõ đường dẫn. Báo cho máy ảo biết phải kết nối với ChromeDriver.exe.

------------------------------------------------------------

	Bước 04: khai báo thư viện lập trình Selenium WebDriver tương ứng với ngôn ngữ lập trình đang sử dụng.

		Khi đưa WebDriver vào trong code bằng cách tải thư viện lập trình, thì lúc này cả trình duyệt (nhờ WebDriver đại diện) được xem là một đối tượng (object), được tải về máy và chiếm bộ nhớ trong RAM, ta có thể thoải mái gọi hàm để điều khiển / yêu cầu trình duyệt thực hiện các thao tác một cách tự động.

------------------------------------------------------------

	Bước 05: sử dụng đối tượng đại diện trong trình duyệt (ví dụ: trinh_dieu_khien_trinh_duyet) để tìm/định vị các phần tử website.

		Mỗi thành phần/thẻ xuất hiện trong cây DOM trên website (web element / web control / tag / component) khi này đều được xem là đối tượng vì nó có giá trị (id, name, color, type...).

			Ví dụ: thẻ <div>, <h>, <span>,...
				-> Đều được xem là đối tượng vì có mô tả, đặc tính và hành vi.

----------------------------------------

Vì đã là một đối tượng nên ta hoàn toàn có thể nhờ trình duyệt tìm giúp ta các thẻ nào đó, khi đó ta sẽ tham chiếu đến thẻ tìm thấy qua loại dữ liệu WebElement (input, button, radio button, checkbox...). Bên cạnh đó, ta còn có thể đưa dữ liệu vào một ô textbox, nhấn được cái nút hoặc hyperlink...; có thể bắt được chữ trên tag để so sánh giá trị và quyết định đúng sai...

Có nhiều cách để tìm thẻ: id, name, class, đường dẫn đến thẻ (XPath)
						<html>
						<body>
							<div>

	Ví dụ 1: trinh_dieu_khien_trinh_duyet.get('https://www.google.com/')
	Ví dụ 2: trinh_dieu_khien_trinh_duyet.find_element(By.NAME, 'q')

(Lưu ý: Khi lập trình sự kiện nhấn một nút trên trình duyệt, hãy sử dụng hàm Submit() khi nút bấm đó là nút bấm thật sự nằm trong form, và sử dụng hàm Click() khi nút bấm đó chỉ là label được chèn hyperlink.)

------------------------------------------------------------

	Bước 06: Xác định hành động, thông qua các API được viết sẵn trong Selenium WebDriver.

------------------------------------------------------------

	Bược 07: Thực thi và kiểm tra kết quả. Selenium WebDriver sẽ gọi trực tiếp trình duyệt thông qua trình điều khiển do chính hãng phát hành trình duyệt đó cung cấp. 

==========================================================================================
==========================================================================================
==========================================================================================

[ĐỊNH NGHĨA VỀ LOCATOR AND SELECTOR]

Khi HTML và CSS kết hợp với nhau sẽ tạo thành một trang web tĩnh, XPath và CSS Selector được xem là địa chỉ của từ khoá.

Khi W3C chuẩn hoá HTML, họ đã đưa ra những kỹ thuật để định vị các thẻ (tag) trong website, kỹ thuật để tìm ra / xác định / chỉ định một thẻ / phần tử (web element) nào đó tại vị trí nào đó trong hàng nghìn thẻ / phần tử khác.
	-> Kỹ thuật Selector (CSS Selector, XPath...) - kỹ thuật định vị một thẻ / phần tử (web element) bất kỳ trong website.

--------------------------------------------------------------------------------

	// Định dạng HTML
	/*
	 * <input class="text form-control"
	 *		  id="txtEmail"
	 *		  name="txtEmail"
	 *		  placeholder="Địa chỉ email"
	 *		  type="email"
	 *		  value="">
	 * */
		
	/*
	 * 1. Dấu mở: < hoặc <>
	 * 2. Tên thẻ (tag name): html, body, head, input, div, form, label, span...
	 * 3. Thuộc tính (attribute name): class, id, name, placeholder, type, value...
	 * 4. Giá trị của thuộc tính (attribute value): "text form-control", "txtEmail"...
	 * 5. Dấu đóng: > hoặc </>
	 * */

--------------------------------------------------------------------------------

Mẹo: https://vananhtooo.wordpress.com/2018/08/10/mot-vai-trick-khi-su-dung-xpath-va-css-selector-trong-selenium/

==========================================================================================

[XPATH VÀ CSS SELECTOR]

--------------------------------------------------------------------------------

[XPATH]

XPath: tìm duyệt/định vị thẻ một cách tương đối trong website (web element locator).
	-> Lần mò theo cây DOM của webiste.

Dựa trên ngôn ngữ XML (bố của HTML), mô tả theo cặp thẻ và đánh dấu ý nghĩa của từng cặp thẻ (Markup Language).

	Ví dụ:
		<div> - Division: phân vùng
		<span> - Span: gom nhóm
		<b> - Bold: in đậm
		<i> - Italic: in nghiêng
		<u> - Underline: gạch chân/gạch dưới

Cấu trúc (tương đối): //tag-name[@attribute-name='attribute-value']

	Ví dụ: //input[@name='login[username]']
		(Website: http://live.techpanda.org/index.php/customer/account/login/)

------------------------------------------------------------

Xpath tuyệt đối: đi qua tất cả các điểm, không được bỏ qua bất kì điểm nào vì sẽ không tìm thấy đường đi. Đưa đầy đủ thông tin, tốc độ chạy nhanh hơn nhưng Test Script sẽ dễ bị sai khi có thay đổi trong XPath.
	-> Chỉ sử dụng khi hết cách.
	Ví dụ: /html/body/div/div/div[2]/div/div/div/form/div/div[2]/div[1]/ul/li[1]/div/input
		(Website: http://live.techpanda.org/index.php/customer/account/login/)

Xpath tương đối: có thể nhảy cóc qua bất kì điểm nào. Đưa rất ít thông tin, tốc độ chạy chậm hơn và chấp việc thay đổi trong XPath.
	Ví dụ: //*[@id='email'] hoặc //input[@id='email']
		(Website: http://live.techpanda.org/index.php/customer/account/login/)

------------------------------------------------------------

Hàm XPath:

* Lấy tuyệt đối: chạy nhanh hơn.
	text()=''
	string()=''
	@attribute=''

		Ví dụ: //strong[text()='Khách hàng mới']
			(Website: https://www.nopcommerce.com/vi/login)

* Lấy tương đối: chạy chậm hơn vì phạm vi quét rộng hơn.
	contains(.,'') = contains(string(),'')
	starts-with(text(),''): lấy chuỗi, giá trị của thuộc tính bắt đầu bằng giá trị nào (nhưng không có ends-with).
		Ví dụ: //div[contains(text(),'bạn sẽ có thể đăng câu hỏi lên diễn đàn')]
			(Website: https://www.nopcommerce.com/vi/login)

Dấu chấm . giúp tìm element ở bất kì đâu miễn là vẫn trong thẻ đó.

----------------------------------------

* Lưu ý: để giúp code dễ đọc hơn:

	1. Ưu tiên sử dụng 'attribute-value' hơn là "attribute-value" vì ở một số IDE, chẳng hạn như Eclipse, sẽ tự động thêm một số kí tự để không bị hiểu nhầm rằng cặp dấu nháy đôi "" vừa được thêm vào là dấu kết thúc.
		Ví dụ:
			// Kí hiệu \" sẽ tự động được IDE thêm vào

			//input[@id=\"txtEmail\"]
			(Website: https://alada.vn/tai-khoan/dang-ky.html)

	2. Dấu sao/hoa thị * (thường thấy khi sao chép XPath từ trình duyệt thay vì gõ thủ công) đại diện cho bất kì thẻ (tag) nào, nếu sử dụng sẽ khiến việc quét bị lâu so với khi truyền tên thẻ trực tiếp do phải đi kiểm tra/so sánh với tất cả các thẻ. Bên cạnh đó, việc sử dụng dấu hoa thị * cũng dễ gây hiểu lầm khi đọc code do không biết đó là loại element gì.
		Ví dụ: //*[@id="txtEmail"]
			(Website: https://alada.vn/tai-khoan/dang-ky.html)

------------------------------------------------------------

* Lưu ý: để việc tìm element được chính xác hơn:

	1. Nếu có từ hai node con giống nhau hoàn toàn trở lên thì ta sẽ xét đến node cha (parent node) của nó, sau đó viết XPath hai lần, một lần cho node cha và một lần cho node con cần tìm.
		Ví dụ:
			// Trong đó: //div[@class='footer'] <- node cha
			// Trong đó: //a[@title='My Account'] <- node con
			// Được hiểu là lấy element với đường link là "My Account" ở phần footer của website

			//div[@class='footer']//a[@title='My Account']
			(Website: https://alada.vn/tai-khoan/dang-ky.html)

--------------------------------------------------------------------------------

[CSS SELECTOR]

CSS Selector: dấu chấm đại diện cho class, dấu thăng đại diện cho các thuộc tính bên trong.

Cấu trúc (tương đối): tag-name[attribute-name='attribute-value']

	Ví dụ: input[name="login[username]"]
		(Website: http://live.techpanda.org/index.php/customer/account/login/)


==========================================================================================

[SỬ DỤNG WAIT TRONG KIỂM THỬ TỰ ĐỘNG]

Trong quá trình thao tác (thường là chuyển trang), do đây là hai luồng (thread) riêng biệt nên cần sử dụng thêm wait để đợi trang kế tiếp trả về phần từ, vì trong nhiều trường hợp trang kế chưa kịp tải nên các phần tử sẽ chưa kịp xuất hiện.
	-> Sử dụng wait khi code chạy nhanh hơn việc trang được nạp.

==========================================================================================

[SỬ DỤNG IDE ĐỂ THIẾT KẾ KỊCH BẢN KIỂM THỬ TỰ ĐỘNG]

** Sử dụng công cụ để ghi hình lại các bước dạng kịch bản (Record & Replay/Playback):


==========================================================================================

[XÁC MINH TRONG SELENIUM IDE VỚI ASSERT VÀ VERIFY]

* Assert: dừng việc test ngay khi có Test Case trả về kết quả fail để có thể điều tra và fix lỗi này ngay, tất cả các Test Case còn lại chưa được chạy đều sẽ bị dừng lại.

--------------------------------------------------------------------------------

* Verify (Soft Assert): vẫn tiếp tục thực hiện kiểm thử tất cả các Test Case khác dù có Test Case trả về kết quả fail, ta sẽ nhận được danh sách kết quả sau khi tất cả các Test Case thực hiện xong bằng cách gọi hàm assertAll().

==========================================================================================

close() vs quit()

close(): đóng duy nhất một trình duyệt đang sử dụng. Nếu có nhiều hơn một trình duyệt đang được mở bởi Selenium, thì câu lệnh này sẽ chỉ đóng trình duyệt mà ta đang trực tiếp thao tác, những trình duyệt còn lại đang được mở sẽ không bị ảnh hưởng.

quit(): đóng toàn bộ những trình duyệt đang sử dụng. Nếu có nhiều hơn một trình duyệt đang được mở bởi Selenium, thì câu lệnh này sẽ tắt toàn bộ Webdriver hiện thời (ngắt đối tượng WebDriver) và đóng hết toàn bộ trình duyệt đang được mở.

	-> Nếu chỉ có duy nhất một trình duyệt đang được mở thì không có sự khác biệt, sự khác biệt chỉ đến khi Selenium đang mở từ hai trình duyệt trở lên.

==========================================================================================

--------------------------------------------------------------------------------

------------------------------------------------------------

----------------------------------------

--------------------

----------






























