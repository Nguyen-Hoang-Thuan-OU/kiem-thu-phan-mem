[NHỮNG CÁCH ĐỂ THỰC THI TEST CASE]

Để thực thi quá trình kiểm thử phần mềm:

	1. Thủ công (Manual): từ công đoạn lên kế hoạch, thiết kế kịch bản và thực thi đều sử dụng sức người.
		-> Con người tự nhập dữ liệu, nhấn nút, so sánh kết quả và kết luận.

	2. Tự động (Automation): con người chỉ tham gia vào công đoạn lên kế hoạch và thiết kế kịch bản, máy tính sẽ đảm nhận phần thực thi.
		-> Con người vết code để máy tính nhập dữ liệu, nhấn nút, so sánh kết quả và kết luận.

==========================================================================================

[TỔNG QUAN VỀ NHỮNG CÁCH TỰ ĐỘNG HOÁ QUÁ TRÌNH KIỂM THỬ]

Có nhiều cách để viết kịch bản kiểm thử tự động (Test Script):
	- Code based / Script based: chủ động lập trình để tự động thực hiện các thao tác.
	- Keyword based / Action based: ghi nhận lại các bước dạng kịch bản và tự động thao tác lại (Record & Replay / Playback), sau đó tự động tạo ra code để tuỳ ý chỉnh sửa tuỳ theo ngôn ngữ lập trình mong muốn.

--------------------------------------------------------------------------------

[KIỂM THỬ TỰ ĐỘNG VỚI CODE]

	* Kịch bản kiểm thử tự động (Test Script / Test Procedure): đoạn code được viết để tự động hoá quá trình kiểm thử, có thể độc lập với ngôn ngữ lập trình được sử dụng để tạo ra ứng dụng.

** Kiểm thử tự động (Automation/Automated Testing): con người sử dụng một ngôn ngữ lập trình và kết hợp thêm các phần mềm khác, công cụ, thư viện tự động hoá (framework)... để thiết kế sẵn kịch bản kiểm thử tự động (Test Script) và nhường lại phần thực thi dành cho máy tính.

	- Đôi khi sẽ có những kịch bản lặp lại nhiều lần đến mức gây nhàm chán, kém hiệu quả sau nhiều lần thực hiện, gây tốn thời gian và chi phí nếu con người tự thực hiện kiểm thử thủ công. Vì vậy, kiểm thử tự động được sinh ra để khắc phục những nhược điểm của kiểm thử thủ cộng.

	- Máy tính sẽ thay mặt con người tự động hoá việc thực thi các Test Case (tự động mở, nhập dữ liệu, nhấn nút, xem kết quả, tự so sánh và báo kết quả đúng sai thông qua email...).

	- Cách này cũng hiệu quả trong việc kiểm thử hồi quy (Regression Testing) vì một tính năng có thể được kiểm thử lại rất nhiều lần, đặc biệt là khi có một tính năng mới được tích hợp vào hoặc khi sửa chữa một tính năng cũ nào đó trong hệ thống.

	- Có thể thực thi kiểm thử tự động định kỳ theo một khung giờ cố định mà không cần đến sự can thiệp và giám sát của con người.

	-> Con người viết code để máy tính giả lập lại (tự động hóa) các hành động, cho phép máy tính thay con người thực hiện kiểm thử hệ thống và kết luận.

	Ví dụ 1: kiểm thử thủ công việc đăng nhập với 100 tài khoản khác nhau.
			-> Công việc lặp lại.
				=> Thiết kế kiểm thử tự động.

	Ví dụ 2: kiểm thử về đa ngôn ngữ trên một hệ thống.
			-> Đã hiểu quy trình kiểm thử thủ công.
				=> Thiết kế kiểm thử tự động.

==========================================================================================
==========================================================================================
==========================================================================================

[CÁC BƯỚC ĐỂ KIỂM THỬ TỰ ĐỘNG]

* Các bước cơ bản để kiểm thử tự động:
	01. Xác định các vùng/mục tiêu trong phần mềm để kiểm thử tự động (biết được mình đang cần kiểm thử cái gì).
	02. Chọn công cụ thích hợp để tự động hoá kiểm thử (sử dụng các công cụ, nền tảng và ngôn ngữ lập trình nào để kiểm thử API, UI, Mobile...).
	03. Lập trình/viết kịch bản kiểm thử (Test Script).
	04. Tạo ra tập hợp các trường hợp kiểm thử (Test Suite), kịch bản kiểm thử hoàn chỉnh (Test Scenario).
	05. Thực thi các kịch bản kiểm thử (Test Script).
	06. Ghi nhận lại kết quả và làm báo cáo.
	07. Phân tích để tìm lỗi hoặc vấn đề về hiệu năng.

==========================================================================================

[CÁC KỸ NĂNG CẦN CÓ ĐỂ KIỂM THỬ TỰ ĐỘNG]

* Danh sách các kỹ năng cần có:

	- Hiểu về các kỹ thuật kiểm thử: để thiết kế được những kịch bản kiểm thử (Test Script) một cách hiểu quả, nhằm tự động hoá quá trình kiểm thử.

	- Biết lập trình: cần có các kỹ năng về lập trình và ngôn ngữ lập trình để có thể viết được Test Script.
		+ Tuân thủ quy ước viết code.
		+ Sử dụng các công nghệ quản lý mã nguồn.

	- Rành về các Web element và Locator: giúp nhận dạng đúng phần tử / đối tượng cần tương tác để tăng độ chính xác cho Test Script.

	- Thành thạo về một Automation Framework: sử dụng thành thạo thư viện của Selenium WebDriver API vì đây là thư viện được sử dụng phổ biến nhất trong việc kiểm thử ứng dụng web.

	- Thành thạo về một Testing Framework: hỗ trợ trong việc xây dựng framework, phân nhóm, quản lý Test Script, chuẩn bị dữ liệu, môi trường kiểm thử...

		+ Tìm hiểu về mẫu thiết kế phần mềm (Design Pattern): hỗ trợ thêm trong việc xây dựng framework.

	- Biết các câu lệnh truy vấn trong hệ quản trị cơ sở dữ liệu.

	- Hiểu biết về mô hình POM (Page - Object - Model).

	- ...

==========================================================================================

[NHỮNG LƯU Ý TRƯỚC KHI KIỂM THỬ TỰ ĐỘNG]

* Nên áp dụng kiểm thử tự động cho:
	- Các dự án lớn và trọng điểm, những dự án dài hạn và tốn nguồn nhân lực.
	- Những dự án yêu cầu kiểm thử thường xuyên trong cùng một lĩnh vực (kiểm thử lặp lại một tính năng).
	- Những yêu cầu không thường xuyên thay đổi.
	- Kiểm thử hiệu năng (Performance Testing): giả lập nhiều người sử dụng cùng một lúc,...
	- Kiểm tra tính ổn định của phần mềm trên quan điểm của kiểm thử thủ công.
	- Tính khả dụng của thời gian.
	- So sánh những điểm ảnh (pixel), màu sắc... của hình ảnh.
	- So sánh những bảng tính (spreadsheets) với rất nhiều dòng và cột.
	- Chạy song song trên nhiều trình duyệt cùng một lúc.

------------------------------------------------------------

	* Ưu tiên áp dụng cho:
		+ Những Test Case passed (Positive).
		+ Test theo thứ tự, ví dụ: đăng ký > đăng nhập > tìm kiếm > chọn mua > thanh toán.
		+ Kiểm thử giao diện (UI): phân trang, ô nhập, nút nhấn...
		+ Kiểm thử hiệu năng (Performance Testing).

--------------------------------------------------------------------------------

* Lưu ý khi lựa chọn kiểm thử tự động:
	- Chi phí khởi đầu (thuê nhân viên, mua công cụ...) cho kiểm thử tự động rất cao.
	- Kiểm thử tự động không phải là 100%, có một số trường hợp không thể kiểm thử tự động.
	- Không kiểm thử tự động với trường hợp UI không cố định.
	- Người kiểm thử tự động nên có kiến thức lập trình tốt.

==========================================================================================

[ƯU VÀ NHƯỢC ĐIỂM CỦA KIỂM THỬ TỰ ĐỘNG]

* Ưu điểm:
	- Cải thiện hiệu quả: nhanh hơn kiểm thử thủ công.
	- Cải thiện độ chính xác: đáng tin cậy hơn con người do bộ dữ liệu kiểm thử đã được chuẩn bị từ trước và đã qua quá trình kiểm tra trước khi đưa vào tự động.
	- Tính tái sử dụng cao: nếu xây dựng được một bộ framework cho riêng mình thì có thể tái sử dụng trong nhiều dự án có cùng cấu trúc (thường do một công ty thiết kế dựa trên một mẫu sẵn có).
	- Tiết kiệm được thời gian: có thể hoạt động 24/7 trong khi con người chỉ có thể bằng 50% hoặc 33% về thời gian hoạt động.
	- Giảm sự nhàm chán: cùng một Test Case nhưng có thể được thực hiện lại nhiều lần trên các loại trình duyệt khác nhau.

--------------------------------------------------------------------------------

* Nhược điểm:
	- Tốn chi phí để trả cho các công cụ tự động hoá chuyên nghiệp (phí bản quyền) và thuê nhân viên có am hiểu về kiểm thử tự động, tốn phí quản lý và bảo trì, tìm hiểu, huấn luyện / đào tạo / giáo dục...
	- Mất thời gian, công sức để tạo mới và chỉnh sửa Test Script.
	- Không phải trường hợp nào cũng phù hợp để kiểm thử tự động.
		Ví dụ: kiểm tra độ đẹp / xấu của UI...

==========================================================================================

[NHỮNG TEST CASE NÀO NÊN VÀ KHÔNG NÊN KIỂM THỬ TỰ ĐỘNG]

* Những Test Case có thể kiểm thử tự động:
	- Rủi ro cao - các Test Case quan trọng.
	- Những Test Case được thực hiện nhiều lần.
	- Những Test Case khó thực hiện thủ công.
	- Những Test Case tốn thời gian của con người.

--------------------------------------------------------------------------------

* Những Test Case không phù hợp để kiểm thử tự động:
	- Những Test Case được thiết kế mới và chưa được thực hiện thủ công ít nhất một lần.
	- Những Test Case có các yêu cầu thường xuyên thay đổi (do khách hàng chưa quyết định được tính năng, hay thay đổi yêu cầu phần mềm,...).
	- Những Test Case được thực hiện đột xuất, không có kế hoạch, kịch bản hay tài liệu tham khảo (ad-hoc). Có những Test Case khi thực thi chỉ để tạm thời giải quyết ngay vào lúc xảy ra vấn đề, không thể tổng quát hoá và tối ưu hoá thành một phương thức để áp dụng về sau này (Random/Monkey Testing).
	- Những Test Case liên tục failed.
	- Những hệ thống áp dụng quá nhiều thiết kế đồ hoạ (hiệu ứng).

==========================================================================================
==========================================================================================
==========================================================================================

[CHI TIẾT VỀ NHỮNG CÁCH THIẾT KẾ KỊCH BẢN KIỂM THỬ TỰ ĐỘNG - TEST SCRIPT]

** Có nhiều cách để thết kế kịch bản kiểm thử tự động (Test Script):

--------------------------------------------------------------------------------

	1. Code based / Script based: chủ động lập trình để bắt các thành phần (component) / phần tử (web element / web control) / thẻ (tag) trên trang web bằng cách sử dụng:
					- Bộ thư viện (Selenium, Appium...)
					- Trình điểu khiển trình duyệt trung gian (Browser WebDriver)
					- Kiến thức lập trình hướng đối tượng (OOP)
						+ Bắt các phần tử trên trang web
						+ Tương tác với các phần tử
					-> Để viết Test Script (Page Object Model - POM)
					   và tự động thực hiện các thao tác.
		-> Sử dụng thư viện lập trình Selenium và ngôn ngữ lập trình.
			(WebDriver)

--------------------------------------------------------------------------------

	2. Keyword based / Action based: ghi nhận lại các bước dạng kịch bản / câu lệnh Selenium (Linear: Record & Replay / Playback) bằng một phần mềm đã được viết sẵn và xây dựng thành một giao diện đồ hoạ người dùng (GUI), nhưng bản chất bên trong vẫn sẽ chứa nhiều thư viện đã được đóng gói.

		- Chuyên phục vụ cho việc ghi hình lại các bước (không phải ghi màn hình dạng video) để tự động hoá thao tác thực thi các Test Case ở mức cơ bản.

		- Trong quá trình xác định các phần tử, các phần tử sẽ được lưu vào một nơi riêng (Object Repository / Element Repository), cho phép tái sử dụng trong nhiều Test Case.

		- Sau khi ghi nhận xong, sẽ in ra một tập các bước đã thực hiện, cho phép can thiệp và chỉnh sửa lại các bước theo phong cách kéo-thả nếu cần thiết.

		- Bên cạnh đó, các công cụ còn hỗ trợ việc chuyển các thao tác ghi nhận các bước thành ngôn ngữ lập trình (Java, C#, Python...) và cho phép chỉnh sửa lại theo phong cách lập trình.

		-> Sử dụng giao diện đồ hoạ kết hợp với ngôn ngữ lập trình.
			(Test Automation Tool)
			- Sử dụng công cụ đồ hoạ Selenium IDE.
			- Sử dụng công cụ record + code: Katalon Studio...
			- Sử dụng công cụ record + code + plug-in: Telerik, Katalon Recorder...

==========================================================================================

[CÁC CÔNG CỤ KIỂM THỬ TỰ ĐỘNG - TEST AUTOMATION FRAMEWORKS]

	* Cây DOM (Document Object Model): do trình duyệt xây dựng lên khi trang web (HTML) đã được tải về máy và nạp vào RAM thông qua quá trình duyệt / lướt web.

		- Toàn bộ các thẻ (tag) / phần tử (element) - cấu trúc trên trang web được xem là đối tượng (object) và đều thuộc lớp (class) WebElement.

		- Trong một đối tượng có thể sẽ có các đối tượng nhỏ hơn, được lồng vào bên trong.

		Ví dụ 1: đối tượng tổng chứa các đối tượng nhỏ hơn trong HTML
			<html>

				<head>
				</head>

				<body>
				</body>

			</html>

		Ví dụ 2: đối tượng tổng chứa các đối tượng nhỏ hơn trong Java

			public static Book {
				private String bookTitle;
				private ... ...;

				// Tên tác giả là một đối tượng thay vì chuỗi,
				// vì họ còn viết rất nhiều sách khác nhau
				// và có nhiều thông tin khác
				private Author author;

				...
			}

--------------------------------------------------------------------------------

** Các công cụ hỗ trợ kiểm thử tự động hai trong một - Studio (Functional Automation Testing Tools): Katalon Studio, akaAT, Telerik, Ranorex, TestComplete, Watir, HP QTP/UFT (Quick Test Professional/Unified Functional Testing)...

	- Dựa trên framework kiểm thử tự động mã nguồn mở (test automation framework) Selenium (web), Appium (desktop, mobile)...
		+ Selenium giống như một bộ thư viện, chuyên cung cấp sẵn các hàm để hỗ trợ trong việc bắt các thành phần (component) trên trang web duyệt theo cấu trúc cây DOM.

	- Sử dụng phần lõi của các thư viện thuần lập trình, nhưng sau đó đóng gói các hàm đã được làm sẵn của thư viện lại thành một ứng dụng để tiện cho việc sử dụng.

	- Lưu lại các phần tử website dưới dạng đối tượng trong Element Repository (Object Repository) và cho phép tái sử dụng trong các Test Case khác nhau của cùng một dự án.

==========================================================================================

[ĐẠI GIA ĐÌNH SELENIUM - BỘ ĐỒ NGHỀ ĐA NĂNG]

Không chỉ là một công cụ đơn lẻ, Selenium là cả một "bộ đồ nghề" (Suite / Set) với một loạt công cụ phần mềm (và thư viện) khác nhau, mỗi công cụ sẽ có những cách tiếp cận khác nhau để hỗ trợ tự động hóa trình duyệt.

	- WebDriver giống như Interface và Selenium implements các tiêu chuẩn về giao thức WebDriver của W3C, cho phép các lập trình viên tận dụng trong quá trình phát triển ứng dụng.

	- Giúp tự động mô phỏng lại những hành vi của người dùng bằng cách định vị và tương tác với các thành phần (component) / phần tử (web element) / thẻ (tag) trong trình duyệt.

	- Mục đích chính là để phục vụ việc kiểm thử tự động cho những ứng dụng web. Nhưng rộng hơn là bất kì tác vụ nào trên nền web.

--------------------------------------------------------------------------------

	[LỊCH SỬ HÌNH THÀNH - SELENIUM HISTORY]

Với tên gọi ban đầu là JavaScriptTestRunner, Selenium được phát triển bởi Jason Huggins vào năm 2004 khi ông đang làm lập trình viên tại ThoughtWorks, mục đích ban đầu của ông là phát triển một thư viện Javascript để chạy tự động các test trên nhiều trình duyệt.

Năm 2006, Simon Stewart - một nhân viên của Google tiếp tục phát triển Selenium với công việc được đặt tên là WebDriver. Nhờ có công cụ này, Google đã nhận được một lượng người sử dụng Selenium rất lớn nhưng đứng trước những hạn chế của sản phẩm thì các tester vẫn phải làm việc rất vất vả.

Năm 2008, Selenium và WebDriver chính thức được kết hợp bởi Selenium đang dần lớn mạnh và WebDriver lại là công cụ của tương lai. Với sự kết hợp này, người dùng được cung cấp một tệp những tính năng lớn.

Cái tên Selenium xuất hiện từ một trò đùa của Huggins dành cho Mercury (công ty đã từng tạo ra một framework thử nghiệm phổ biến hơn khi Selenium đang trong quá trình phát triển) - đối thủ cạnh tranh của mình.

* Tham khảo thêm:
	- https://www.selenium.dev/history/
	- https://viettuts.vn/selenium

--------------------------------------------------------------------------------

	[HỆ SINH THÁI - SELENIUM ECOSYSTEM]

Trong hơn 10 năm qua, một hệ sinh thái gồm nhiều dự án mã nguồn mở đã được xây dựng để phục vụ cho Selenium và lấy Selenium WebDriver làm trọng tâm.

------------------------------------------------------------

		[TRÌNH DUYỆT HỖ TRỢ - BROWSERS]

		Có thể hoạt động được trên nhiều trình duyệt khác nhau với những WebDriver tương ứng:

			1. Firefox: Mozilla GeckoDriver
			2. Edge: Microsoft EdgeDriver
			3. Chrome: Google ChromeDriver
			4. Opera: Opera ChromiumDriver
			5. Safari: Apple SafariDriver
			6. Internet Explorer: InternetExplorerDriver

------------------------------------------------------------

		[NGÔN NGỮ LẬP TRÌNH - LANGUAGE BINDINGS]

		Cần sử dụng một ngôn ngữ lập trình để có thể tạo ra các kịch bản (script) nhằm tương tác với Selenium Server (Remote WebDriver) hoặc tương tác với Selenium WebDriver dưới cục bộ.

			01. C#
			02. Java
			03. Python
			04. JavaScript
			05. Ruby

			06. Go
			07. Haskell
			08. Perl
			09. PHP
			10. R
			11. Dart
			12. Pharo Smalltalk

------------------------------------------------------------

		[HỆ ĐIỀU HÀNH - OPERATING SYSTEMS]

		Có thể hoạt động được trên nhiều hệ điều hành khác nhau:

			1. Microsoft Windows: tuy chỉ sử dụng những phiên bản mới nhất của hệ điều hành Windows để kiểm thử và sửa lỗi cho dự án Selenium, nhưng miễn là phiên bản của Windows còn được Microsoft hỗ trợ, thì chắc chắn sẽ sử dụng được Selenium.

			2. macOS: dù dạo gần đây không từng sử dụng bất kỳ phiên bản nào của macOS để kiểm thử cho dự án Selenium, nhưng vẫn có hỗ trợ phiên bản ổn định và thường không phải là phiên bản mới nhất.

			3. Linux: Ubuntu là nền tảng kiểm thử chính của dự án Selenium, nhưng những biến thể khác của Linux vẫn sẽ hoạt động tốt miễn là các nhà phát hành trình duyệt còn hỗ trợ.

------------------------------------------------------------

		[FRAMEWORKS]

		Programming languages are supported through Selenium drivers. These are libraries made for each language that expose commands from the Selenium API natively in the form of methods/functions.

		Selenium is often used for automating web applications for testing purposes, but it does not include a testing framework. Some testing frameworks that can be used with Selenium are listed below.

			- Ruby:
				+ Watir
				+ Capybara

			- JavaScript:
				+ WebdriverIO
				+ CodeceptJS
				+ Nightwatch.js

			- Java:
				+ FluentLenium
				+ QAF
				+ Selenide

			- Python:
				+ Helium
				+ Nerodia
				+ SeleniumBase

--------------------------------------------------------------------------------

	[CÁC THÀNH PHẦN - SELENIUM COMPONENTS]

* Tham khảo thêm: https://www.selenium.dev/documentation/overview/components/

--------------------------------------------------------------------------------

	[CÁC DỰ ÁN SELENIUM - SELENIUM PROJECTS]

	* Tài nguyên kiểm thử:
		1. Kịch bản kiểm thử tự động (Test scripts): Mã nguồn để kiểm thử trình duyệt và so sánh kết quả.

		2. Dữ liệu kiểm thử (Test data): Những dữ liệu được sử dụng trong những tình huống, ngữ cảnh khác nhau.

		3. Cấu hình kiểm thử (Test configuration): Các tập tin cấu hình liên quan đến môi trường kiểm thử (ví dụ: đường dẫn trang web, trình duyệt đang sử dụng...).

		4. Báo cáo kiểm thử (Test reporting): Những báo cáo thu được sau khi thực thi kiểm thử, nêu chi tiết kết quả kiểm thử: thành công, thất bại và bỏ qua...

		5. Công cụ hỗ trợ kiểm thử (Test utilities): Chứa các lớp và hàm được xây dựng sẵn để tái sử dụng trong những trường hợp lặp lại (ví dụ: tương tác với những phần tử quen thuộc, xử lý lỗi...).

Là một "bộ sưu tập đồ nghề" với nhiều công cụ khác nhau, mỗi công cụ sẽ đáp ứng từng nhu cầu kiểm thử khác nhau. Là sự kết hợp của nhiều dự án khác nhau để tạo thành một hệ thống kiểm thử đa năng.
	- Được gọi là một Framework vì có cung cấp đẩy đủ các loại công cụ, thư viện và các hướng dẫn để quản lý dự án kiểm thử.
	- Tạo ra một quy chuẩn cần phải tuân theo để quản lý mã nguồn một cách hiệu quả (ví dụ: các tập tin nên được phân chia như thế nào...).
	- Giúp những tài nguyên kiểm thử cũng dễ dàng hơn trong việc bảo trì, mở rộng và tái sử dụng theo thời gian.

	-> Tiêu chuẩn hoá cách thức tổ chức mã nguồn.

Nhưng cần lưu ý, bản thân Selenium lại không phải là một Testing Framework.
	- Vì vậy, để sử dụng thêm một số tính năng nâng cao, ta cần sử dụng thêm một số Testing Framework để hỗ trợ như: TestNG, JUnit, NUnit, PyUnit, Cucumber...
	- Những tính năng đó có thể là:
		- Gom nhóm và sắp xếp độ ưu tiên cho các tình huống kiểm thử.
		- Thực hiện kiểm thử hướng dữ liệu (DDT).
		- Kiểm thử song song trên nhiều trình duyệt.
		- Thực thi hàng loạt, so sánh và báo cáo kết quả kiểm thử...
		- Tập hợp những cú pháp (annotations) để cung cấp dữ liệu, khai báo sự phụ thuộc lẫn nhau giữa các tình huống kiểm thử, 

* Bộ đồ nghề Selenium (Selenium Suite) bao gồm:

------------------------------------------------------------

	1. Selenium IDE: với tên cũ là Selenium Recorder và được ra mắt vào năm 2006.

		- Đây là một tiện ích mở rộng (Plug-in / Add-on / Extension), ban đầu chỉ có thể sử dụng được trên trình duyệt Firefox, nhưng sau đó đã mở rộng ra và có thể sử dụng trên Chrome và Edge.

		- Hỗ trợ ghi nhận lại các bước dạng kịch bản (Record & Replay / Playback) và quản lý theo bộ (Suite), giúp tự động mô phỏng lại những thao tác của người dùng trên trình duyệt.

		- Thường được sử dụng để tạo ra những đoạn kịch bản (Selenium Script) đơn giản hoặc để kiểm thử thăm dò (Exploratory Testing) mà không cần phải có quá nhiều kiến thức về lập trình.

		-> Tiện ích mở rộng trên trình duyệt, giúp ghi nhận lại các bước dạng kịch bản.

		* Selenese / Selenium command: là ngôn ngữ miền chuyên biệt / ngôn ngữ đặc tả chuyên biệt (Domain-specific language - DSL) của Selenium IDE. Selenese cung cấp một tập hợp gồm nhiều câu lệnh (Action, Accessor và Assertion), được sử dụng để tự động hoá các tương tác trên web.
			-> Ngôn ngữ đặc biệt để viết Test Script của Selenium IDE.

			(* Tham khảo thêm: https://www.selenium.dev/documentation/legacy/selenium_ide/#selenium-commands--selenese)

------------------------------------------------------------

	2. Selenium RC (Remote Control) / (Selenium 1): phiên bản đầu tiên của Selenium, được ra mắt vào năm 2004.

		- Selenium Remote Control (RC) là một Server ảo được viết bằng Java, làm trung gian giao tiếp giữa người dùng và trình duyệt bằng cách nhận các câu lệnh, phiên dịch và báo cáo kết quả của việc thực thi.

		-> Sử dụng ngôn ngữ lập trình để điều khiển trình duyệt, Selenium Remote Control sẽ làm Server ảo trung gian.

------------------------------------------------------------

	3. Selenium WebDriver - 2/3/4: phiên bản nâng cấp của Selenium RC (hợp nhất Selenium RC và Selenium WebDriver), ra mắt vào năm 2009.

		- Phần lõi (core) của Selenium chính là Selenium WebDriver.

		- Là một interface và cho phép người dùng viết code để làm việc trực tiếp với trình duyệt ở mức độ hệ điều hành mà không cần đến Server ảo nữa.

		- Cung cấp API đa trình duyệt (cross-browser API), cho phép điều khiển nhiều trình duyệt khác nhau bằng nhiều ngôn ngữ lập trình khác nhau.

		- Công dụng chính của Selenium WebDriver là tự động hoá việc kiểm thử trên các ứng dụng web.

		-> Cung cấp các hàm và cho phép sử dụng ngôn ngữ lập trình để điều khiển trình duyệt.

------------------------------------------------------------

	4. Selenium Grid: được ra mắt vào năm 2008.

		- Selenium Hub là tính năng dùng để chạy Test Script một cách phân tán và song song trên nhiều máy tính - WebDriver node (khi cần chạy Test Script trên nhiều hệ điều hành, trình duyệt / phiên bản của trình duyệt...) mà không cần phải chỉnh sửa lại Test Script, đã được code sẵn trong Selenium, chỉ việc lấy và sử dụng.

		- Mục đích chính là để giảm thời gian thực hiện và tăng phạm vi thử nghiệm.

		-> Chạy Test Script cùng một lúc trên nhiều tổ hợp máy, hệ điều hành, trình duyệt và phiên bản khác nhau.

		(* Tham khảo thêm: https://vananhtooo.wordpress.com/2017/09/26/selenium-grid-la-gi/)

(* Tham khảo thêm: https://en.wikipedia.org/wiki/Selenium_(software))

--------------------------------------------------------------------------------

	[TÓM TẮT VỀ SELENIUM]

* Tóm tắt về Selenium:
	- Là một dự án ô mã nguồn mở.
	- Chuyên được sử dụng để tự động hoá kiểm thử cho ứng dụng web.
	- Hoạt động được trên nhiều trình duyệt và nền tảng: Microsoft Windows, macOS, Linux.
	- Hỗ trợ nhiều ngôn ngữ lập trình: C#, Java, Python, JavaScript, Ruby...

Tuỳ thuộc vào ngữ cảnh mà Selenium có thể là:
	- Công cụ. (chính thống, chỉ phục vụ cho nền tảng web)
	- Framework.
	- Thư viện. (có thể được import vào trong một project để sử dụng)

==========================================================================================
==========================================================================================
==========================================================================================

[SỬ DỤNG IDE ĐỂ GHI NHẬN KỊCH BẢN KIỂM THỬ TỰ ĐỘNG]

** Sử dụng công cụ để ghi nhận lại các bước dạng kịch bản (Record & Replay / Playback):

--------------------------------------------------------------------------------

	Bước 01: Truy cập các trang chủ của Selenium IDE hoặc trang cửa hàng trực tuyến của trình duyệt (ví dụ: Chrome Web Store, Firefox Add-ons, Microsoft Edge Add-ons) để tải tiện ích mở rộng về và cài đặt vào trình duyệt.
		| https://www.selenium.dev/selenium-ide/

--------------------------------------------------------------------------------

	Bước 02: Tạo mới một dự án để chứa nhiều Test Script bên trong bằng tuỳ chọn "Create a new project" và đặt tên cho dự án.

--------------------------------------------------------------------------------

	Bước 03: Tạo mới một Test Case bằng tuỳ chọn "Add new test" và đặt tên cho Test Case (thuộc về một dự án).

--------------------------------------------------------------------------------

	Bước 04: Dán URL của trang web muốn kiểm thử vào thanh địa chỉ "Playback base URL".

		// Tương đương với các câu lệnh của Selenium WebDriver
			| WebDriver myBrowser = new ChromeDriver();
			| myBrowser.get("https://google.com");

--------------------------------------------------------------------------------

	Bước 05.01: Sử dụng tính năng ghi nhận (Record).

		1. Tại giao diện của Selenium IDE, bấm nút [Start recording] ở góc trên-bên phải hoặc sử dụng phím tắt [Ctrl] + [U] để bắt đầu ghi nhận lại (Record) toàn bộ những thao tác đã thực hiện thủ công theo một tình huống mong muốn.

		2. Thao tác theo theo Test Case đã được thiết kế.

		3. Sau khi hoàn thành các thao tác, quay trở lại giao diện của Selenium IDE và nhấn nút [Stop recording].

		4. Đặt tên cho Test Script vừa thao tác và được tạo tự động xong.

		5. Các thao tác thủ công đã được ghi nhận lại theo từng bước. Lúc này, ta có thể chỉnh sửa lại theo ý muốn và loại bỏ đi những thao tác thừa (ví dụ: Nhấn chuột, phóng to màn hình...).

		6. Nhấn nút [Run current test] để mô phỏng lại (Replay / Playback) theo đúng những gì đã ghi nhận (Record) mỗi khi có nhu cầu thực thi Test Script.

------------------------------------------------------------

	Bước 05.02: Viết mã để thực hiện.

		- Command: chứa các lệnh đã được thiết kế sẵn, ta chỉ việc chọn để tạo Test Script hoặc thậm chí là tự khai báo biến để sử dụng riêng.

		- Target: áp dụng thêm cách kỹ thuật locator để chỉ định chính xác vị trí của thành phần / đối tượng cần tương tác.

		- Value: đặt giá trị cho thành phần / đối tượng chỉ định trong target nếu cần (ví dụ: giá trị cho ô textbox...) để làm dữ liệu đầu vào, dữ liệu so sánh...

--------------------------------------------------------------------------------

	Bước 06: [Tuỳ chọn] Một số thao tác có thể sử dụng trong quá trình kiểm thử trang web bằng Selenium IDE.

		- So sánh (Assert) hoặc kiểm tra (Verify) các phần tử.
			| Trỏ chuột hoặc quét chọn > Chuột phải > Selenium IDE > Assert / Verify

		- Điều chỉnh tốc độ thực thi của Test Case bằng nút [Test execution speed].

		- Chuyển đổi các kịch bản trên IDE thành mã lập trình với nhiều ngôn ngữ lập trình khác nhau.
			| Trỏ chuột vào tên Test Case > [⋮] > [Export]

			// Tích chọn các tuỳ chọn
				[✓] Include origin tracing code comments
				[✓] Include step description as a separate comment
				[ ] Export for use on Selenium Grid

==========================================================================================

[XÁC MINH TRONG SELENIUM IDE VỚI ASSERT VÀ VERIFY]

* Assert: nếu trong quá trình thực thi Test Case mà trả về kết quả so sánh là fail, lập tức dừng ngay việc test và tất cả các Test Case còn lại chưa được thực thi đều cũng sẽ bị dừng.
	-> So sánh và dừng nếu fail.

--------------------------------------------------------------------------------

* Verify (Soft Assert): vẫn tiếp tục thực hiện kiểm thử tất cả các Test Case khác dù có Test Case trả về kết quả fail, ta sẽ nhận được danh sách kết quả sau khi tất cả các Test Case thực hiện xong bằng cách gọi hàm assertAll().
	-> Chỉ kiểm tra chứ không dừng nếu fail.

==========================================================================================
==========================================================================================
==========================================================================================

[SỬ DỤNG WEBDRIVER ĐỂ THIẾT KẾ KỊCH BẢN KIỂM THỬ TỰ ĐỘNG]

	* W3C (World Wide Web Consortium): tổ chức tiêu chuẩn quốc tế chính cho World Wide Web. Hiệp hội này chuyên phát triển và đề xuất các tiêu chuẩn cho World Wide Web, giúp chuẩn hoá các khái niệm liên quan đến web - Tổ chức quốc tế quản lý sự phát triển web và sự phát triển của các công nghệ có thể tương tác để phát huy hết tiềm năng của Web.

Có nhiều hãng thiết kế trình duyệt web (Mozilla, Google, Apple, Microsoft...) với những trình duyệt khác nhau, nhưng tất cả đều tuân thủ và thiết kế theo tiêu chuẩn do W3C đã đưa ra, từ đó giúp dễ dàng hơn trong việc tương thích.

	Ví dụ: để cạnh tranh, các trình duyệt khác nhau quyết định hỗ trợ những bộ thẻ khác nhau, gây khó khăn cho các lập trình viên, khiến một số website chỉ hoạt động tốt ở một số trình duyệt nhất định.
		-> W3C giúp chuẩn hoá và thống nhất trong thiết kế trình duyệt.

Mặc định, trình duyệt sẽ được người dùng điều khiển thông qua các ô nhập, nút nhấn, mở tab mới, lưu dấu trang, xoá dữ liệu duyệt web... Nhưng trong bộ tiêu chuẩn khi thiết kế trình duyệtcủa W3C có một tiêu chuẩn mang ý nghĩa rằng: "Mọi trình duyệt nên cho phép lập trình viên điều khiển được hoạt động của trình duyệt thông qua code", để giúp cho QC tự động hoá quá trình kiểm thử website dưới góc nhìn của người dùng.

	- Phần "hậu trường" của một trang web cũng chỉ là các thẻ (tag) / phần tử (element) / thành phần (component) và bên trong chứa những giá trị, thuộc tính...
	
	- Vì vậy, bên cạnh việc thao tác thủ công trên màn hình giao diện, ta hoàn toàn có thể viết code để tự động hóa được quá trình kiểm thử.

	- Lúc này, trình duyệt chính là một đối tượng (object), cung cấp các hàm cho các lập trình viên và cho phép tương tác thông qua việc gọi hàm.

	-> Cho phép code đóng vai người dùng để sử dụng trình duyệt.

------------------------------------------------------------

* Tham khảo thêm:
	- https://w3c.github.io/webdriver/
	- https://www.w3.org/TR/webdriver/

--------------------------------------------------------------------------------

[KIẾN TRÚC CỦA SELENIUM WEBDRIVER]

** Kiến trúc của Selenium WebDriver (Selenium 3):

	Python			Selenium		GeckoDriver		FireFox
	Java			client			ChromeDriver		Chrome
	C#			library			SafariDriver		Safari


								  HTTP over HTTP Server
								-------------------------
								|			|
								|			v
----------------------    ----------------------    ---------------------    ---------------
| Ngôn ngữ lập trình |--->| Thư viện lập trình |--->| Browser WebDriver |--->| Trình duyệt |
----------------------    ----------------------    ---------------------    ---------------
								^			|
								|			|
			    JSON Wire Protocol			-------------------------
			    Over HTTP				  HTTP over HTTP Server
			 (Không còn được sử dụng
			  ở Selenium 4)


// Có thể hình dung:
				JDBC, ADO.NET			Database Engine: SQL Server,
			(Vừa kết nối với Database Engine,			 Oracle, MySQL
			vừa cung cấp bộ thư viện
			để giao tiếp với Driver)

--------------------------------------------------------------------------------

[NHỮNG CÔNG CỤ CẦN PHẢI CÓ ĐỂ ĐIỀU KHIỂN TRÌNH DUYỆT]

Đối với người dùng, việc tương tác với trình duyệt sẽ chỉ đơn giản là thông qua giao diện, vì trình duyệt được thiết kế để họ dễ dàng sử dụng.

Nhưng đối với các kiểm thử viên tự động (Automation Tester), với nhu cầu kiểm thử một ứng dụng web, để tương tác và điều khiển được trình duyệt thông qua ngôn ngữ lập trình, thì phải sử dụng thêm cầu nối trung gian (trình điều khiển - driver - thư viện), giúp giao tiếp với trình duyệt thật sự.

** Quy trình viết kịch bản kiểm thử tự động bằng việc chủ động lập trình:

------------------------------------------------------------

	[1. BỘ THƯ VIỆN LẬP TRÌNH SELENIUM - SELENIUM WEBDRIVER API]

	* Client library / Client library API: cung cấp API để giao tiếp giữa ngôn ngữ lập trình và WebDriver.
		- Cho phép sử dụng ngôn ngữ lập trình để chạy các lệnh Selenium bằng cách cung cấp một loạt các hàm thông qua API.
		- Mỗi ngôn ngữ lập trình khác nhau sẽ có gói thư viện khác nhau.
		- Có nhiệm vụ nhận các câu lệnh và đưa sang cho Selenium Server để tiến hành kiểm thử, đồng thời cũng sẽ nhận các kết quả trả về và trả về cho ứng dụng. Ứng dụng sẽ lưu kết quả xử lý vào một biến và kiểm tra xem thành công hay thất bại.

----------------------------------------

** Thư viện lập trình (Selenium WebDriver API): để điều khiển được trình duyệt thì bắt buộc phải sử dụng code, kèm theo đó là những thư viện được gói trong package / namespace và chuyên cung cấp các hàm phục vụ cho việc lập trình.

	- Là tập hợp gồm nhiều lớp (class) trừu tượng, hay còn được gọi là Interface, được đóng gói theo một định dạng cụ thể (*.jar, *.dll, *.exe...).
		+ Chuyên cung cấp các lệnh (API), cho phép lập trình viên sử dụng những ngôn ngữ lập trình khác nhau như: Java, Python, C#, Ruby...
		+ Nói cách khác, Selenium WebDriver đại diện cho một đối tượng (object) trình duyệt và cung cấp các lệnh / hàm.
	
	- Vì đã là thư viện nên cách sử dụng cũng sẽ giống hệt như mọi thư viện khác trong ngôn ngữ lập trình, phải tải về và thêm thủ công vào dự án hoặc khai báo tên thư viện theo dạng phụ thuộc (Dependency).

	- Khi chạy Test Script, Selenium WebDriver sẽ gọi trực tiếp (direct call) cho trình duyệt thông qua chính trình điều khiển trình duyệt (Browser WebDriver) mà nhà phát triển trình duyệt đấy cung cấp. Sau đó, các hành động trong Test Script sẽ được thực thi.

	-> Cung cấp API và cho phép điều khiển nhiều trình duyệt khác nhau bằng nhiều ngôn ngữ lập trình khác nhau.

		* Chi tiết lời gọi trực tiếp (direct call):

			1. Với mỗi một hành động từ Test Script, một thông điệp HTTP Request sẽ được tạo ra để gửi các yêu cầu từ Client lên Server.

			2. HTTP Request đó sẽ được gửi đến Browser WebDriver.

			3. Mỗi Browser WebDriver sẽ có một HTTP Server để tiếp nhận HTTP request.

			4. Sau khi nhận được thông điệp, HTTP Server xác định những bước cần thiết để thực thi hành động phản hồi lại yêu cầu.

			5. HTTP Server mô phỏng lại các thao tác theo đúng những bước đã được thiết kế trong Test Script.

			6. Sau đó, HTTP Server trả lại trạng thái thực hiện những hành động cho Client, nơi đang thực thi Test Script.

------------------------------------------------------------

	[2. TRÌNH ĐIỀU KHIỂN TRÌNH DUYỆT - BROWSER WEBDRIVER / PROXY]

	* Protocol: giao thức chung (giống như ngôn ngữ trung gian) để giúp Selenium WebDriver và trình duyệt có thể hiểu nhau. WebDriver của trình duyệt (đại diện cho trình duyệt) sẽ hiểu giao thức và từ đó giúp giao tiếp được với Selenium WebDriver.

	* JSON Wire Protocol: giao thức này sẽ không còn được hỗ trợ kể từ Selenium 4.

	* WebDriver W3C: giao thức mới thay thế cho JSON Wire Protocol.

	(* Tham khảo thêm:
		- https://anhtester.com/blog/nhung-tinh-nang-moi-trong-selenium-4-b464.html
		- https://youtu.be/6iHdvOYdJk8 - Selenium 4 with Simon Stewart and BrowserStack)

----------------------------------------

** Trình điều khiển trình duyệt (Browser WebDriver): vì theo quy chuẩn của W3C thì trình duyệt phải được thiết kế mở, đi kèm với trình duyệt sẽ là một "người anh em song sinh", rất am hiểu vể trình duyêt nên có thể điều khiển được trình duyệt.

	- Bản thân trình duyệt là một thế giới riêng và rất phức tạp, người sử dụng thông thường sẽ không thể can thiệp trực tiếp thông qua code được.
		+ Và để đảm bảo tính trừu tượng (Abstraction) của việc thiết kế mà những thư viện lập trình (Selenium) cũng không được trực tiếp can thiệp vào trình duyệt.
		+ Vì vậy, Browser WebDriver sẽ làm cầu nối trung gian và đảm nhận việc tương tác giữa trình duyệt và thư viện lập trình (Selenium).

	- Browser WebDriver là một ứng dụng / trình điều khiển / cầu nối trung gian (giống như Proxy) - Interface để kết nối giữa trình duyệt thực tế và thư viện lập trình.
		+ Đến từ nhiều nhà phát triển khác nhau với những cái tên khác nhau, bao gồm: ChromeDriver, OperaDriver, GeckoDriver...
		+ Có nhiệm vụ nhận các câu lệnh do thư viện lập trình (Selenium) gửi, sau đó thao tác lại trên trình duyệt thật.		

	- Bộ quy chuẩn chung được tách riêng cho khỏi trình duyệt. Là đoạn code chạy song song với trình duyệt, có kết nối với thư viện lập trình (Selenium), từ đó cho phép ngôn ngữ lập trình (Python, Java, C#...) can thiệp vào trình duyệt để kiểm thử những ứng dụng web một cách tự động bằng code.

	- Việc giao tiếp giữa thư viện lập trình Selenium WebDriver API và Browser WebDriver sẽ được thực hiện thông qua giao thức W3C WebDriver (tên cũ là JSON Wire Protocol)

	-> Tập tin nhị phân biết cách giao tiếp với trình duyệt và thư viện lập trình.

(* Tham khảo thêm: https://www.selenium.dev/documentation/webdriver/)

------------------------------------------------------------

	[3. TRÌNH DUYỆT - BROWSER]

** Trình duyệt (Browser): giúp đưa con người đến mọi nơi trên internet, cho phép họ xem văn bản, hình ảnh và video từ mọi nơi trên thế giới.

	- Các trình duyệt hiện đại sẽ thường tự động cập nhật phiên bản mới nhất.

	- Vì những phiên bản khác nhau của cùng một trình duyệt đã có thể khác nhau về câu lệnh, nên yêu cầu phải có sự đồng bộ / tương thích giữa hai phiên bản của trình duyệt và trình điều khiển trình duyệt.

	- Việc đồng bộ phiên bản sẽ giúp tránh gặp những lỗi không mong muốn phát sinh trong quá trình thiết kế và thực thi Test Script.
		Ví dụ: lỗi "This version of ChromeDriver only supports Chrome version 1xx"

	-> Nơi mọi thao tác của con người sẽ diễn ra (cần có một Browser WebDriver với phiên bản phù hợp để tương tác).

==========================================================================================

[CÁC BƯỚC CƠ BẢN CẦN THỰC HIỆN ĐỂ THIẾT KẾ KỊCH BẢN KIỂM THỬ TỰ ĐỘNG]

** Các yêu cầu để viết kịch bản kiểm thử (Test Script):

	1. Thư viện lập trình (Selenium Automation Framework): Selenium (tuỳ vào ngôn ngữ lập trình).

	2. Trình điều khiển trình duyệt (Browser WebDriver): phần trung gian để kết nối với trình duyệt, thay con người điều khiển trình duyệt.

	3. Trình duyệt (Browser): nến có thể, hãy chọn những trình duyệt ít phát hành phiên bản cập nhật (ví dụ: Firefox...).

(* Tham khảo thêm:
	- https://www.selenium.dev/documentation/webdriver/getting_started/install_library/
	- https://giangtester.com/bai-1-selenium-webdriver-la-gi/)

--------------------------------------------------------------------------------

	[THIẾT KẾ KỊCH BẢN KIỂM THỬ VỚI SELENIUM WEBDRIVER]

	(Hướng dẫn thao tác trên hệ điều hành Windows
	 với ngôn ngữ lập trình Java & Python,
	 sử dụng trình duyệt Google Chrome | Lõi (Kernel): Chromium)

** Các bước viết code (Test Script) để tự động hoá những thao tác của QC / Người dùng khi sử dụng một website (điều khiển trình duyệt) bằng Selenium WebDriver:

------------------------------------------------------------

	Bước 00: Tải trình duyệt và đảm bảo trình duyệt đã được cài ở đường dẫn mặc định (C:\Program Files\Google\Chrome\Application\).

		- Có thể kiểm tra bằng cách gõ trực tiếp đường dẫn "chrome://version/" vào trình duyệt.

		- Nếu không cài ở đường dẫn mặc định, ta vẫn có thể yêu cầu ChromeDriver sử dụng đường dẫn tuỳ chọn: https://chromedriver.chromium.org/capabilities

------------------------------------------------------------

	Bước 01: Kiểm tra phiên bản hiện tại của trình duyệt và sau đó tải xuống ChromeDriver (tập tin nhị phân *.exe) tương ứng với phiên bản (và kiến ​​trúc) đang sử dụng.

		1. Kiểm tra phiên bản của trình duyệt:
			Help -> About Google Chrome
			(Hoặc sử dụng: chrome://version/)

		2. Tải phiên bản ChromeDriver tương ứng với phiên bản hiện tại của trình duyệt.
			- https://chromedriver.chromium.org/downloads
			- https://chromedriver.storage.googleapis.com/index.html

------------------------------------------------------------

	Bước 02: Tải thư viện Selenium WebDriver và những thư viện phụ thuộc đi kèm khác, tương ứng với ngôn ngữ lập trình.

		* Java:
			+ Ant: https://github.com/SeleniumHQ/selenium/releases/
			+ Maven: https://mvnrepository.com/artifact/org.seleniumhq.selenium/selenium-java

			// Có thể chỉ cần tải riêng một số thư viện như: Selenium API, Selenium Chrome Driver, Selenium Chromium Driver...

------------------------------------------------------------

	Bước 03: Cho Selenium WebDriver biết tập tin ChromeDriver nằm ở đâu trong máy tính.

		Cách 1 - Sử dụng biến môi trường Path trong hệ điều hành để lưu đường dẫn đến tập tin ChromeDriver.

		Cách 2 - Tạo mới một dự án và sao chép tập tin ChromeDriver.exe vào trong cùng thư mục chứa dự án, môi trường ảo (venv - python) hoặc bất kì đường dẫn nào mà ta mong muốn. Điều này sẽ giúp dễ quản lý khi đưa lên Server (ví dụ: GitHub...) và sử dụng mà không cần khai báo đường dẫn quá dài, nếu để ở nơi khác không cùng với thư mục chứa dự án thì phải chỉ rõ đường dẫn hoặc khai báo biến môi trường.

			* Java:
				// Vào ngay trong thư mục chứa dự án
				// để đi tìm Browser WebDriver
				String duongDanChuaBrowserWebDriver = "chromedriver.exe";
				//	-> Khai báo đường dẫn chứa Browser WebDriver

				// Nếu để ở nơi khác thì phải khai báo đầy đủ đường dẫn
				//  Ví dụ: "D:\\swt\\project\\chromedriver.exe"
				//
				// (Sử dụng hai dấu '\\' để tránh những ký hiệu đặc biệt trong lập trình,
				//  ví dụ: '\n' để xuống hàng)

------------------------------------------------------------

	Bước 04: Báo cho máy ảo biết phải kết nối với ChromeDriver.exe (giống như việc khai báo biến môi trường trong Windows, nhưng đây là khai báo ảo trong môi trường ảo).

		* Java:
			// Báo cho máy ảo Java biết rằng
			// có một biến môi trường (dành riêng cho máy ảo)
			// với tên biến là "webdriver.chrome.driver"
			// và trỏ đến giá trị là chromedriver.exe
			// (chứa trong biến duongDanChuaBrowserWebDriver)

			System.setProperty("webdriver.chrome.driver", duongDanChuaBrowserWebDriver);
			//	-> Thiết lập biến môi trường
			//	   và ánh xạ đến đường dẫn ChromeDriver

------------------------------------------------------------

	Bước 05: Khai báo thư viện lập trình Selenium WebDriver tương ứng với ngôn ngữ lập trình đang sử dụng.

		* Java:
			import org.openqa.selenium.WebDriver;
			import org.openqa.selenium.chrome.ChromeDriver;

------------------------------------------------------------

	Bước 06: Sử dụng đối tượng đại diện trong trình duyệt (ví dụ: trinhDuyetCuaToi, trinh_dieu_khien_trinh_duyet) để tìm / định vị các phần tử website.

		- Khi duyệt web, bản thân trang web đó đã được tải về máy dưới dạng HTML, tốn một vùng RAM và hiển thị (render) trực tiếp lên trình duyệt thay vì được tải thành một tập tin rời.

		- Khi trang web được tải về RAM, nó được xem là một đối tượng bự nhất - cây DOM.
			+ Mỗi thành phần / thẻ xuất hiện trong cây DOM đều được xem là những đối tượng nhỏ hơn vì bên trong có thể chứa giá trị (id, name, color, type, margin, padding...), hành vi hoặc tiếp tục chứa những đối tượng khác.
			+ Mỗi thẻ sẽ được đại diện bằng một Interface trong Selenium được gọi là WebElement.

			Ví dụ: thẻ <div>, <h>, <span>,...
				-> Đều được xem là đối tượng vì có mô tả, đặc tính và hành vi.

		- Vì trang web đã được tải về trình duyệt, mà lại có một đối tượng nào đó đại diện cho trình duyệt (đối tượng được tạo từ lớp WebDriver), nghĩa là đối tượng này cũng đã nắm được toàn bộ đối tượng trong trang web (nắm được mã nguồn của trang web).

		(Lúc này, Browser WebDriver sẽ bắt đầu phát huy công dụng khi dựa theo những lệnh trong code mà bắt đầu tương tác với trình duyệt thật.)

		* Java:
			// Khi đưa WebDriver vào trong code
			// bằng cách tải thư viện lập trình,
			// thì lúc này cả trình duyệt (nhờ WebDriver đại diện)
			// được xem là một đối tượng (object),
			// được tải về máy (hiển thị trực tiếp lên trình duyệt)
			// và chiếm bộ nhớ trong RAM,
			// ta có thể thoải mái gọi hàm
			// để điều khiển / yêu cầu trình duyệt
			// thực hiện các thao tác một cách tự động

			// Tạo một đối tượng trình duyệt mới
			// và trỏ thẳng vào trình duyệt vật lý
			WebDriver trinhDuyetCuaToi = new ChromeDriver();

						     // Đây là một trình duyệt mới hoàn toàn
						     // và đại diện cho trình duyệt thật,
						     // nhưng sẽ không ảnh hưởng
						     // đến trình duyệt đang sử dụng
						     // và có thể được điều khiển
						     // thông qua đối tượng trinhDuyetCuaToi

			// Sử dụng đối tượng trinhDuyetCuaToi
			// để bắt đầu tương tác
			và mở trình duyệt ở chế độ toàn màn hình
			trinhDuyetCuaToi.manage().window().maximize();

------------------------------------------------------------

	Bước 07: Định vị các thẻ và xác định hành động, thông qua các API được viết sẵn trong Selenium WebDriver.

		- Vì đã là một đối tượng nên ta hoàn toàn có thể nhờ trình duyệt tìm giúp ta các thẻ nào đó.
		
		- Nhưng để đưa ra yêu cầu, trước hết ta phải biết thẻ đó (input, button, radio button, checkbox...) nằm ở đâu thông qua loại dữ liệu.
			+ Có rất nhiều kỹ thuật khác nhau để tìm ra vị trí của một thẻ, từ cách tiện lợi nhất là sử dụng định danh (id) cho đến những cách chuyên nghiệp như sử dụng CSS Selector và XPath.
			+ Sau khi đã biết được vị trí, ngoài việc lấy dữ liệu về, ta còn có thể đưa dữ liệu vào một ô textbox, nhấn các nút hoặc hyperlink, có thể bắt được chữ trên tag để so sánh giá trị và quyết định đúng sai...

		- Sau khi sử dụng đối tượng đại diện cho trình duyệt để tìm ra được phần tử dựa theo các kĩ thuật định vị, ta sẽ lưu trữ lại phần tử đó vào một đối tượng khác đại diện cho phần tử.

		* Java:
			import org.openqa.selenium.By;
			import org.openqa.selenium.WebElement;

			myBrowser.get("https://www.google.com/");
        
			// Sử dụng đối tượng đại diện cho trình duyệt
			// để tìm phần tử nằm trong trang web,
			// sau đó lưu phần tử vừa tìm được vào đối tượng
			// đại diện cho từng phần tử trong trang web
        		WebElement searchBox = myBrowser.findElement(By.name("q"));

			// Sử dụng đối tượng đại diện cho phần tử
			// để bắt đầu tương tác với trang web
			searchBox.sendKeys("Kiểm thử phần mềm");
			searchBox.submit();

		* Python:
			trinh_dieu_khien_trinh_duyet.get('https://www.google.com/')
			trinh_dieu_khien_trinh_duyet.find_element(By.NAME, 'q')

------------------------------------------------------------

	Bược 08: Thực thi và kiểm tra kết quả. Selenium WebDriver sẽ gọi trực tiếp trình duyệt thông qua trình điều khiển do chính hãng phát hành trình duyệt đó cung cấp.

--------------------------------------------------------------------------------

* Lưu ý: Nếu tạo dự án Java bằng Maven, đôi khi sẽ vì lỗi [https://stackoverflow.com/a/75741758/7429447] mà khi thực thi mã nguồn, trình duyệt sẽ được mở nhưng trang web lại không thể nạp được; thường gặp trong trình duyệt Chrome ở phiên bản từ 111 trở lên và khi sử dụng bản Selenium quá cũ.

	| NetBeans: Failed to execute goal org.codehaus.mojo:exec-maven-plugin:1.5.0:exec (default-cli) on project ...

	| Eclipse: java.io.IOException: Invalid Status code=403 text=Forbidden

	* Cách khắc phục:

		1. Nếu sử dụng Selenium phiên bản dưới 4.5:

			// Trong mã nguồn
			ChromeOptions tuyChonTrinhDuyet  = new ChromeOptions();
			tuyChonTrinhDuyet.addArguments("--remote-allow-origins=*");
			WebDriver myBrowser = new ChromeDriver(tuyChonTrinhDuyet);

		2. Nếu sử dụng Selenium phiên bản từ 4.5 trở lên:

			// Trong tập tin pom.xml
			<dependency>
				<groupId>org.seleniumhq.selenium</groupId>
				<artifactId>selenium-http-jdk-client</artifactId>
				<version>4.8.1</version>
			</dependency>

			// Trong mã nguồn
			System.setProperty("webdriver.http.factory", "jdk-http-client");

--------------------------------------------------------------------------------

	[CODE CƠ BẢN ĐỂ ĐIỀU KHIỂN TRÌNH DUYỆT BẰNG JAVA]



==========================================================================================

[NHỮNG LƯU Ý & MẸO TRONG QUÁ TRÌNH SỬ DỤNG SELENIUM WEBDRIVER]

--------------------------------------------------------------------------------

	[NGÔN NGỮ MẶC ĐỊNH CHO TRÌNH DUYỆT]

Khi muốn chọn ngôn ngữ hiển thị mặc định cho trình duyệt, ta sẽ tuân theo tiêu chuẩn ISO 639-1:
	- Hai kí tự đầu tiên đại diện cho ngôn ngữ.
	- Hai kí tự tiếp theo đại diện cho quốc gia.

	Ví dụ: Cách chọn ngôn ngữ mặc định khi khởi động trình duyệt.

		ChromeOptions tuyChonTrinhDuyet  = new ChromeOptions();

		tuyChonTrinhDuyet.addArguments("--lang=en-GB");
		// Ngôn ngữ: English (en)
		// Quốc gia: UNITED KINGDOM (GB)

		tuyChonTrinhDuyet.addArguments("--lang=vi-VN");
		// Ngôn ngữ: Vietnamese (vi)
		// Quốc gia: VIET NAM (VN)

* Tham khảo thêm:
	- Mã ngôn ngữ: https://www.w3schools.com/tags/ref_language_codes.asp
	- Mã quốc gia: https://www.w3schools.com/tags/ref_country_codes.asp
	- Danh sách kết hợp mã ngôn ngữ và quốc gia: http://www.lingoes.net/en/translator/langcode.htm

(Đây chỉ là ngôn ngữ hiển thị, việc định vị cho vị trí địa lý sẽ còn phụ thuộc vào những yếu tố khác.)

--------------------------------------------------------------------------------

	[CHẾ ĐỘ ẨN DANH TRONG SELENIUM]

Khi sử dụng Selenium để mở trình duyệt ở chế độ ẩn danh:

	import org.openqa.selenium.chrome.ChromeOptions;

	ChromeOptions tuyChonTrinhDuyet  = new ChromeOptions();
	tuyChonTrinhDuyet.addArguments("--incognito");
	
	WebDriver myBrowser = new ChromeDriver(tuyChonTrinhDuyet);

Nhưng vì đây là một chế độ đặc biệt và WebDriver đã tối giản ở mức vừa đủ để sử dụng, nên một số tuỳ chọn và tình năng sẽ luôn ở trạng thái mặc định.
	- Tiện ích mở rộng đã cài đặt sẽ không xuất hiện ở chế độ này.
	- Một số trang sẽ yêu cầu xác nhận địa chỉ / vị trí để cung cấp thêm một số dịch vụ, nhưng vì không thể tự động theo dõi nên sẽ hiển thị cửa sổ thông báo để yêu cầu cung cấp thông tin.

* Lưu ý: Việc ẩn danh chỉ che giấu được hành vi ở phía người dùng, không thể giấu được nhà mạng và trang web.

--------------------------------------------------------------------------------

	[TỰ ĐỘNG CẬP NHẬT PHIÊN BẢN CHO WEBDRIVER CỦA TRÌNH DUYỆT BẰNG WEBDRIVERMANAGER]

Khi muốn sử dụng Selenium, mặc kệ code được viết trong hàm main() hoặc hàm Unit Test, thì điều quan trọng nhất để đảm bảo code luôn chạy đúng đó là: phiên bản của trình duyệt phải trùng với phiên bản của WebDriver do chính hãng làm nên trình duyệt đó cung cấp.
	-> Luôn phải kiểm tra phiên bản của trình duyệt và WebDriver một cách thủ công.

Đóng gói toàn bộ các câu lệnh: kiểm tra phiên bản, tải WebDriver, khai báo đường dẫn, thông báo cho máy ảo, duy trì sự đồng bộ giữa các phiên bản... thành một lớp riêng tên là "WebDriverManager" dưới dạng tập tin *.jar.
	-> Đóng gói các thao tác tốn thời gian thành thư viện WebDriverManager.

------------------------------------------------------------

WebDriverManager là một thư viện nguồn mở của Java, được sử dụng để tự động tải xuống và cập nhật phiên bản cho Browser WebDriver.

(* Tham khảo thêm: https://bonigarcia.dev/webdrivermanager/)

* Các bước để sử dụng WebDriverManager trong dự án Java:

----------------------------------------

	Bước 01: Khai báo thư viện phụ thuộc (Dependency) theo phong cách Maven hoặc Gradle. Khai báo trong phạm vị (scope) là các lớp để test.

----------------------------------------

	Bước 02: Trong hàm main(), khai báo biến để đại diện cho trình duyệt và thuộc thư viện WebDriver của Selennium.
		Ví dụ: WebDriver trinhDuyetCuaToi;

----------------------------------------

	Bước 03.01: [Tuỳ chọn] Đi tìm thư viện phụ thuộc (Dependency) cho WebDriver đã khai báo ở trên bằng cách chọn "Search Dependency at Maven Repository...". Lúc này, IDE sẽ đi vào thư mục m2 dưới máy cục bộ để đi tìm.

		(Trong quá trình đi tìm thư viện, nếu không tìm thấy dù đã tải thư viện về kho chứa cục bộ, thì có thể Clean and Build Project)

----------------------------------------

	Bước 03.02: [Tuỳ chọn] Khai báo thư viện WebDriver của Selennium bằng cách import.

----------------------------------------

	Bước 04: Gọi phương thức setup() trong thư viện WebDriverManager của Boni García.
		Ví dụ: WebDriverManager.chromedriver().setup();

		(Có thể tìm kiếm trong kho cục bộ nếu không tìm thấy và khai báo thư viện giống như bước 03.)

----------------------------------------

	Bước 05: Tạo đối tượng trình duyệt và trỏ thẳng vào trình duyệt vật lý, nhưng vẫn độc lập với trình duyệt vật lý.
		Ví dụ: trinhDuyetCuaToi = new ChromeDriver();

		(Có thể tìm kiếm trong kho cục bộ nếu không tìm thấy và khai báo thư viện giống như bước 03.)

--------------------------------------------------------------------------------

	[PHÂN BIỆT GIỮA SUBMIT() VÀ CLICK()]

Khi lập trình sự kiện nhấn một nút trên trình duyệt:
	- Sử dụng hàm Submit() khi nút bấm đó là nút bấm thật sự nằm trong form.
	- Sử dụng hàm Click() khi nút bấm đó chỉ là label được chèn hyperlink.

--------------------------------------------------------------------------------

	[CỬA SỔ THÔNG BÁO NỔI]

Trong quá trình tương tác với trình duyệt bằng Selenium sẽ có hai dạng cửa sổ thông báo nổi.

	1. Của riêng ứng dụng: tương tác trong trang đã được trình duyệt tải về.
		-> Tương tác giống như những thẻ bình thường khác.

	2. Của riêng trình duyệt:
		-> Tương tác trực tiếp bằng đối tượng đại diện cho trình duyệt (ví dụ: trinhDuyetCuaToi, trinh_dieu_khien_trinh_duyet).

--------------------------------------------------------------------------------

	[CƠ CHẾ CHỜ ĐỢI / ĐỒNG BỘ]

Trong quá trình thao tác (thường là chuyển trang), do câu lệnh điều khiển (chạy trên máy ảo) và trang web (chạy trên trình duyệt) là hai luồng (thread) riêng biệt nên cần sử dụng thêm wait để câu lệnh đợi trang kế tiếp trả về phần từ, vì trong nhiều trường hợp trang kế chưa kịp tải nên các phần tử sẽ chưa kịp xuất hiện.

	- Trong một số trang web, để tăng tốc độ tải khi có nhiều hình ảnh, có thể trang sẽ không render ra hết toàn bộ nội dung (các thẻ, hình ảnh...) trong một lần mà sẽ tải về theo từng phần.

	- Vì những lý do khách quan, chẳng hạn như kết nối mạng không ổn định... hoặc những lý do chủ quan, chẳng hạn như bản thân trang không được tối ưu nên việc xử lý sẽ tốn thời gian... mà việc tải được hết toàn bộ nội dung của trang web sẽ tốn một khoảng thời gian nhất định.

	- Việc trình duyệt tải trang về máy tính và code để điều khiển là hai luồng (thread) bất đồng bộ (async). Code chỉ có thể ra lệnh chứ không thể can thiệp vào và điều khiển tốc độ tải của trang vì đây đã là công việc của trình duyệt, nên đôi khi sẽ có hiện tượng những câu lệnh của Selenium sẽ được thực thi nhanh hơn mức cần thiết so với tốc độ nạp của trang web, dẫn đến sự không đồng bộ và không tìm thấy phần tử để tương tác (no such element).

	-> Sử dụng wait để đồng bộ tốc độ khi code chạy nhanh hơn việc trang được nạp.
		(Câu lệnh chạy nhanh, nhưng trang web lại có độ trễ trong việc tải nội dung.)

------------------------------------------------------------

Có hai loại wait:

	- Tường minh (Explicit): khá đơn giản nếu đã có kinh nghiệm trong việc đợi và tính được khoảng thời gian gần chính xác để tải được toàn bộ trang web, sử dụng thông qua lớp Thread. Lúc này, ta sẽ yêu cầu các câu lệnh chủ động "đứng hình mất vài giây" trước khi tiếp tục quay lại xử lý.
		-> Ước lượng trước khoảng thời gian cần chờ.

	- Ngầm định (Implicit): khó viết nhưng sẽ an toàn hơn. Do Selenium cung cấp sẵn và sử dụng thông qua đối tượng đại diện cho trình duyệt. thông báo rằng không nên vội tìm các phần tử mà hãy đợi đến khi trang web được tải xong (giống như việc xem tín hiệu trong bảng điều khiển Network của trình duyệt). Tuy không nói rõ sẽ chờ trong bao lâu, chỉ biết khi nào trang web được tải xong thì các câu lệnh mới được tiếp tục thực thi.
		-> Chờ đợi đến khi nhìn thấy dấu hiệu.

--------------------------------------------------------------------------------

	[XỬ LÝ NGOẠI LỆ]

Thay vì phải trực tiếp xử lý ngoại lệ, ta có thể "uỷ quyền" cho một nơi khác để xử lý giùm.

	Ví dụ: xử lý ngoại lệ khi có sử dụng hàm sleep()

		// 01. Ném ra bên ngoài thông báo rằng có thể xảy ra ngoại lệ,
		//     nơi nào sử dụng / gọi hàm thì phải xử lý ngoại lệ
		public static void testGoogleWithInIncognitoMode() throws InterruptedException {

			...

			// Đây là hàm thao tác với hệ điều hành
			// để ép ứng dụng phải "đứng hình mất 3 giây",
			// nên có thể phát sinh vấn đề
			// liên quan đến bộ lập trình (scheduler)
			// và phát sinh ngoại lệ,
			// vì vậy, phải bắt ngoại lệ
			Thread.sleep(3000);

			// Nhưng thay vì tự mình xử lý ngoại lệ,
			// thì lại để cho nơi gọi hàm tự xử lý ngoại lệ
		}

		// 02. Nơi nào gọi main() thì cũng phải tự xử lý ngoại lệ,
		//     mà người gọi main() ở đây lại chính là hệ điều hành,
		//     nên nếu có xảy ra thì hệ điều hành sẽ tự xử lý
		//     bằng cách kết thúc tiến trình (end task)
		public static void main(String[] args) throws InterruptedException {
			testGoogleWithInIncognitoMode();
		}

--------------------------------------------------------------------------------

	[XỬ LÝ CHUỖI]

Cắt bớt chuỗi thừa bằng Java:

	Ví dụ: Trong trang web https://www.thegioididong.com/, một số sản phẩm sẽ có thêm dấu '*' nằm ngay phía sau giá bán.

		// Bị thừa kí tự '*' trong giá bán
		String price = "290₫ *";

		// Lấy và in ra được vị trí của kí tự '*'
		// (trả về kết quả -1 nếu không tìm thấy kí tự)
		int index = price.indexOf('*');
		System.out.println("index: " + index);

		// Kiểm tra kết quả trả về,
		// nếu tìm thấy thì xoá kí tự thừa đi
		String afterPrice = price;
		if (index >= 0)
			afterPrice = price.substring(0, price.length() - 2);

		// In ra giá bán cuối cùng
		System.out.println("Final price (after removing *): "
					+ afterPrice);

--------------------------------------------------------------------------------

	[PHÂN BIỆT PHƯƠNG THỨC CLOSE() VÀ QUIT()]

close(): đóng duy nhất một trình duyệt đang sử dụng. Nếu có nhiều hơn một trình duyệt đang được mở bởi Selenium, thì câu lệnh này sẽ chỉ đóng trình duyệt mà ta đang trực tiếp thao tác, những trình duyệt còn lại đang được mở sẽ không bị ảnh hưởng.

quit(): đóng toàn bộ những trình duyệt đang sử dụng. Nếu có nhiều hơn một trình duyệt đang được mở bởi Selenium, thì câu lệnh này sẽ tắt toàn bộ WebDriver hiện thời (ngắt đối tượng WebDriver) và đóng hết toàn bộ trình duyệt đang được mở.

	-> Nếu chỉ có duy nhất một trình duyệt đang được mở thì không có sự khác biệt, sự khác biệt chỉ đến khi Selenium đang mở từ hai trình duyệt trở lên.

==========================================================================================
==========================================================================================
==========================================================================================

[KỸ THUẬT ĐỊNH VỊ CÁC THẺ TRONG TRANG WEB - BỘ ĐỊNH VỊ LOCATOR]

	* Crawler (Spider / Spiderbot): kỹ thuật sử dụng Selenium và Locator để tự động truy cập vào các trang web và lấy dữ liệu.

--------------------------------------------------------------------------------

	[ĐỊNH NGHĨA]

Khi HTML và CSS kết hợp với nhau sẽ tạo thành một trang web tĩnh, Locator được xem là địa chỉ của từ khoá.

Bên cạnh việc định nghĩa ra cách thiết kế trình duyệt (phải có cách để lập trình viên can thiệp vào), W3C còn định nghĩa thêm cho những thứ có liên quan đến HTML.

	- Khi W3C chuẩn hoá HTML, họ đã đưa ra những cách / kỹ thuật / cơ chế để định vị được các thẻ (tag) / phần tử (web element) trong website, kỹ thuật để tìm ra / xác định / chỉ định một thẻ nào đó tại vị trí nào đó trong hàng nghìn thẻ khác của một trang HTML khi nó đã được tải về máy tính.

	- Một khi đã định vị chính xác được phần tử cần tìm, thì sẽ lấy được các sự kiện (event) và gửi yêu cầu đến để phần tử làm một công việc nào đó. Vì vậy, việc xác định được chính xác phần tử đóng vai trò rất quan trọng trong việc thành công của một Test Script.

	-> Locator (CSS Selector, XPath...) - kỹ thuật mò vào trong trang web đã được Server trả về máy tính (trong DOM) để định vị chính xác một phần tử cụ thể giữa vô vàn phần tử khác, sau đó tương tác với phần tử này.
		(Giống như một câu truy vấn để lấy dữ liệu trong các hệ quản trị cơ sở dữ liệu.)

--------------------------------------------------------------------------------

	[TÌM PHẦN TỬ TRÊN TRÌNH DUYỆT BẰNG CÔNG CỤ DÀNH CHO NHÀ PHÁT TRIỂN]

Có hai kiểu tìm phần tử:
	- Tuyệt đối: Đi từ gốc của cây phân cấp.
	- Tương đối: 

* Cách định vị các phần tử ngay trên trình duyệt (Windows):

------------------------------------------------------------

	Bước 01: mở Công cụ dành cho Nhà phát triển (Web Developer Tools / Browser Developer Tools).

		* Sử dụng phím tắt (Shortcut):

			- Chrome:
				1. Sử dụng phím tắt [F12]
					-> Mở bảng điều khiển Elements

				2. Sử dụng tổ hợp phím [Ctrl] + [Shift] + [I]
					-> Mở bảng điều khiển Elements

				2. Sử dụng tổ hợp phím [Ctrl] + [Shift] + [J]
					-> Mở bảng điều khiển Console

			- Firefox:
				1. Sử dụng phím tắt [F12]
					-> Mở bảng điều khiển Inspector

				2. Sử dụng tổ hợp phím [Ctrl] + [Shift] + [I]
					-> Mở bảng điều khiển Inspector

		* Sử dụng menu ngữ cảnh (Context Menu):

			- Chrome: Chuột phải > Inspect

			- Firefox: Chuột phải > Inspect (Q)

		* Sử dụng biểu tượng [⋮] hoặc [≡]:

			- Chrome: More tools > Developer tools

			- Firefox: More tools > Web Developer Tools

------------------------------------------------------------

	Bước 02: chọn / định vị phần tử cần tương tác để xem các thông tin về thuộc tính.

		* Sử dụng phím tắt (Shortcut):

			- Chrome: [Ctrl] + [Shift] + [C]

			- Firefox: [Ctrl] + [Shift] + [C]

		* Sử dụng biểu tượng:

			- Chrome: [Select an element in the page to inspect it] > Rê chuột đến phần tử cần định vị

			- Firefox: [Pick an element from the page] > Rê chuột đến phần tử cần định vị

------------------------------------------------------------

	Bước 03: sao chép định vị của phần tử.

		* Tận dụng Công cụ dành cho Nhà phát triển (Web Developer Tools / Browser Developer Tools):

			- Chrome: Chuột phải > Copy > Chọn loại locator muốn sử dụng

			- Firefox: Chuột phải > Copy > Chọn loại locator muốn sử dụng

		* Sử dụng thêm tiện ích mở rộng:

			- SelectorsHub.

			- ChroPath.

------------------------------------------------------------

	Bước 04: kiểm tra lại xem liệu định vị vừa sao chép có phải là duy nhất.

		* Sử dụng khung tìm kiếm được tính hợp bằng phím tắt để viết câu truy vấn:

			- Chrome: trong bảng điều khiển Elements > [Ctrl] + [F]

			- Firefox: trong bảng điều khiển Inspector > [Ctrl] + [F]

==========================================================================================

[CÁC CHIẾN LƯỢC ĐỊNH VỊ PHẦN TỬ TRÊN WEB - LOCATOR STRATEGIES]

Có rất nhiều cách khác nhau để xác định chính xác và duy nhất một phần tử (element) trong trang web.

Selenium cung cấp lớp "By", bên trong gồm nhiều phương thức (ví dụ: className, cssSelector, id, linkText, name, partialLinkText, taName, xpath...) để hỗ trợ tìm các phần tử trong DOM.

--------------------------------------------------------------------------------

	[ĐỊNH VỊ TRUYỀN THỐNG - TRADITIONAL LOCATOR]

Có 8 chiến lược / kỹ thuật định vị truyền thống trong WebDriver:

	[Các thẻ trùng nhau sẽ được đánh số từ 1]

	1. Class name: Sử dụng thuộc tính class để tìm đối tượng.
		- Thường có thể tìm ra được một loạt các thẻ có cùng tên class, vì thẻ này là để áp dụng hàng loạt.
		- Không cho phép có nhiều tên class - compound class name (ví dụ: nếu tên class đặt có khoảng trắng, thì sẽ được tính là hai tên class.).

	2. CSS Selector: Tận dụng cú pháp của CSS trong việc chọn phần tử.

	3. Id: Theo quy định thiết kế của W3C, id không nên trùng nhau (nhưng chưa cấm hẳn).
		- Vì vậy, sử dụng thuộc tính id để tìm chính xác phần tử.
		- Đây là cách tiện lợi và nhanh gọn nhất.

	4. Name: Sử dụng thuộc tính name.

	5. Link Text: Sử dụng đoạn văn bản được hiển thị trong siêu liên kết (hyperlink).

	6. Partial Link Text: Sử dụng một phần của đoạn văn bản được hiển thị trong siêu liên kết (hyperlink). Nếu có nhiều kết quả được tìm thấy, thì kết quả đầu tiên sẽ được chọn.

	7. Tag Name: Sử dụng tên của thẻ / bộ thẻ.

	8. XPath: Sử dụng biểu thức XPath - ngôn ngữ được sử dụng để truy vấn trong XML.

(* Tham khảo thêm:
	- https://www.toolsqa.com/selenium-webdriver/selenium-locators/
	- https://www.selenium.dev/documentation/webdriver/elements/locators/)

(* Mẹo: https://vananhtooo.wordpress.com/2018/08/10/mot-vai-trick-khi-su-dung-xpath-va-css-selector-trong-selenium/)

--------------------------------------------------------------------------------

	[ĐỊNH VỊ TƯƠNG ĐỐI - RELATIVE LOCATOR / FRIENDLY LOCATOR]

Được giới thiệu từ Selenium 4.

==========================================================================================

[XPATH VÀ CSS SELECTOR]

Các chỉ số sẽ bắt đầu từ 1 thay vì 0 giống như mảng trong lập trình.

--------------------------------------------------------------------------------

	[XPATH]

XPath: tìm duyệt/định vị thẻ một cách tương đối trong website (web element locator).
	-> Lần mò theo cây DOM của webiste.

Dựa trên ngôn ngữ XML (bố của HTML), mô tả theo cặp thẻ và đánh dấu ý nghĩa của từng cặp thẻ (Markup Language).

	Ví dụ:
		<div> - Division: phân vùng
		<span> - Span: gom nhóm
		<b> - Bold: in đậm
		<i> - Italic: in nghiêng
		<u> - Underline: gạch chân/gạch dưới

Cấu trúc (tương đối): //tag-name[@attribute-name='attribute-value']

	Ví dụ: //input[@name='login[username]']
		(Website: http://live.techpanda.org/index.php/customer/account/login/)

------------------------------------------------------------

XPath tuyệt đối (Absolute / Full): đi qua tất cả các điểm, không được bỏ qua bất kì điểm nào vì sẽ không tìm thấy đường đi. Đưa đầy đủ thông tin, tốc độ chạy nhanh hơn nhưng Test Script sẽ dễ bị sai khi có thay đổi trong XPath.
	-> Xuất phát từ gốc và đi đến đích. Chỉ sử dụng khi hết cách.

	Ví dụ: /html/body/div/div/div[2]/div/div/div/form/div/div[2]/div[1]/ul/li[1]/div/input
		(Website: http://live.techpanda.org/index.php/customer/account/login/)

XPath tương đối (Relative): có thể nhảy cóc qua bất kì điểm nào. Đưa rất ít thông tin, tốc độ chạy chậm hơn và chấp việc thay đổi trong XPath.
	-> Không nói rõ đường đi, xuất phát tại một điểm nào đó và sau đó đi tiếp.

	Ví dụ: //*[@id='email'] hoặc //input[@id='email']
		(Website: http://live.techpanda.org/index.php/customer/account/login/)

------------------------------------------------------------

Hàm XPath:

* Lấy tuyệt đối: chạy nhanh hơn.
	text()=''
	string()=''
	@attribute=''

		Ví dụ: //strong[text()='Khách hàng mới']
			(Website: https://www.nopcommerce.com/vi/login)

* Lấy tương đối: chạy chậm hơn vì phạm vi quét rộng hơn.
	contains(.,'') = contains(string(),'')
	starts-with(text(),''): lấy chuỗi, giá trị của thuộc tính bắt đầu bằng giá trị nào (nhưng không có ends-with).
		Ví dụ: //div[contains(text(),'bạn sẽ có thể đăng câu hỏi lên diễn đàn')]
			(Website: https://www.nopcommerce.com/vi/login)

Dấu chấm . giúp tìm element ở bất kì đâu miễn là vẫn trong thẻ đó.

----------------------------------------

* Lưu ý: để giúp code dễ đọc hơn:

	1. Ưu tiên sử dụng 'attribute-value' hơn là "attribute-value" vì ở một số IDE, chẳng hạn như Eclipse, sẽ tự động thêm một số kí tự để không bị hiểu nhầm rằng cặp dấu nháy đôi "" vừa được thêm vào là dấu kết thúc.
		Ví dụ:
			// Kí hiệu \" sẽ tự động được IDE thêm vào

			//input[@id=\"txtEmail\"]
			(Website: https://alada.vn/tai-khoan/dang-ky.html)

	2. Dấu sao/hoa thị * (thường thấy khi sao chép XPath từ trình duyệt thay vì gõ thủ công) đại diện cho bất kì thẻ (tag) nào, nếu sử dụng sẽ khiến việc quét bị lâu so với khi truyền tên thẻ trực tiếp do phải đi kiểm tra/so sánh với tất cả các thẻ. Bên cạnh đó, việc sử dụng dấu hoa thị * cũng dễ gây hiểu lầm khi đọc code do không biết đó là loại element gì.
		Ví dụ: //*[@id="txtEmail"]
			(Website: https://alada.vn/tai-khoan/dang-ky.html)

------------------------------------------------------------

* Lưu ý: để việc tìm element được chính xác hơn:

	1. Nếu có từ hai node con giống nhau hoàn toàn trở lên thì ta sẽ xét đến node cha (parent node) của nó, sau đó viết XPath hai lần, một lần cho node cha và một lần cho node con cần tìm.
		Ví dụ:
			// Trong đó: //div[@class='footer'] <- node cha
			// Trong đó: //a[@title='My Account'] <- node con
			// Được hiểu là lấy element với đường link là "My Account" ở phần footer của website

			//div[@class='footer']//a[@title='My Account']
			(Website: https://alada.vn/tai-khoan/dang-ky.html)

--------------------------------------------------------------------------------

	[CSS SELECTOR]

CSS Selector: dấu chấm đại diện cho class, dấu thăng đại diện cho các thuộc tính bên trong.

	- Dấu khoảng trắng đại diện cho thẻ con.

Cấu trúc (tương đối): tag-name[attribute-name='attribute-value']

	Ví dụ: input[name="login[username]"]
		(Website: http://live.techpanda.org/index.php/customer/account/login/)

==========================================================================================

[KỸ THUẬT TƯƠNG QUAN - AXES / AXIS]

Nếu trong các trang web có sử dụng thêm những framework phức tạp, cấu trúc sẽ tự động được tạo, khiến những giá trị trong các thuộc tính liên tục bị thay đổi sau mỗi lần F5.
	-> Định vị bị thay đổi sau mỗi lần chạy.

Sử dụng kỹ thuật định vị tương đối để tìm những phần tử khi chúng có dính líu, liên hệ với nhau (có tương quan), mà không cần quan tâm đến tên thẻ hay thuộc tính của thẻ.
	-> Định vị dựa trên sự tương đối giữa các thẻ.

==========================================================================================
==========================================================================================
==========================================================================================

==========================================================================================

==========================================================================================

==========================================================================================

* Tự học thêm:
	- https://www.techlistic.com/p/selenium-tutorials.html

==========================================================================================

--------------------------------------------------------------------------------

------------------------------------------------------------

----------------------------------------

--------------------

----------






























