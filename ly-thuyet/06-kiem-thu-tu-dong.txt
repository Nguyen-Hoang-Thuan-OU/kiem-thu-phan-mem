[NHỮNG CÁCH ĐỂ THỰC THI TEST CASE]

Để thực thi quá trình kiểm thử phần mềm:

	1. Thủ công (Manual): từ công đoạn lên kế hoạch, thiết kế kịch bản và thực thi đều sử dụng sức người.
		-> Con người tự nhập dữ liệu, nhấn nút, so sánh kết quả và kết luận.

	2. Tự động (Automation): con người chỉ tham gia vào công đoạn lên kế hoạch và thiết kế kịch bản, máy tính sẽ đảm nhận phần thực thi.
		-> Con người vết code để máy tính nhập dữ liệu, nhấn nút, so sánh kết quả và kết luận.

==========================================================================================

[TỔNG QUAN VỀ NHỮNG CÁCH TỰ ĐỘNG HOÁ QUÁ TRÌNH KIỂM THỬ]

Có nhiều cách để viết kịch bản kiểm thử tự động (Test Script):
	- Code based / Script based: chủ động lập trình để tự động thực hiện các thao tác.
	- Keyword based / Action based: ghi nhận lại các bước dạng kịch bản và tự động thao tác lại (Record & Replay / Playback), sau đó tự động tạo ra code để tuỳ ý chỉnh sửa tuỳ theo ngôn ngữ lập trình mong muốn.

--------------------------------------------------------------------------------

[KIỂM THỬ TỰ ĐỘNG VỚI CODE]

	* Kịch bản kiểm thử tự động (Test Script / Test Procedure): đoạn code được viết để tự động hoá quá trình kiểm thử, có thể độc lập với ngôn ngữ lập trình được sử dụng để tạo ra ứng dụng.

** Kiểm thử tự động (Automation/Automated Testing): con người sử dụng một ngôn ngữ lập trình và kết hợp thêm các phần mềm khác, công cụ, thư viện tự động hoá (framework)... để thiết kế sẵn kịch bản kiểm thử tự động (Test Script) và nhường lại phần thực thi dành cho máy tính.

	- Đôi khi sẽ có những kịch bản lặp lại nhiều lần đến mức gây nhàm chán, kém hiệu quả sau nhiều lần thực hiện, gây tốn thời gian và chi phí nếu con người tự thực hiện kiểm thử thủ công. Vì vậy, kiểm thử tự động được sinh ra để khắc phục những nhược điểm của kiểm thử thủ cộng.

	- Máy tính sẽ thay mặt con người tự động hoá việc thực thi các Test Case (tự động mở, nhập dữ liệu, nhấn nút, xem kết quả, tự so sánh và báo kết quả đúng sai thông qua email...).

	- Cách này cũng hiệu quả trong việc kiểm thử hồi quy (Regression Testing) vì một tính năng có thể được kiểm thử lại rất nhiều lần, đặc biệt là khi có một tính năng mới được tích hợp vào hoặc khi sửa chữa một tính năng cũ nào đó trong hệ thống.

	- Có thể thực thi kiểm thử tự động định kỳ theo một khung giờ cố định mà không cần đến sự can thiệp và giám sát của con người.

	-> Con người viết code để máy tính giả lập lại (tự động hóa) các hành động, cho phép máy tính thay con người thực hiện kiểm thử hệ thống và kết luận.

	Ví dụ 1: kiểm thử thủ công việc đăng nhập với 100 tài khoản khác nhau.
			-> Công việc lặp lại.
				=> Thiết kế kiểm thử tự động.

	Ví dụ 2: kiểm thử về đa ngôn ngữ trên một hệ thống.
			-> Đã hiểu quy trình kiểm thử thủ công.
				=> Thiết kế kiểm thử tự động.

==========================================================================================
==========================================================================================
==========================================================================================

[CÁC BƯỚC ĐỂ KIỂM THỬ TỰ ĐỘNG]

* Các bước cơ bản để kiểm thử tự động:
	01. Xác định các vùng/mục tiêu trong phần mềm để kiểm thử tự động (biết được mình đang cần kiểm thử cái gì).
	02. Chọn công cụ thích hợp để tự động hoá kiểm thử (sử dụng các công cụ, nền tảng và ngôn ngữ lập trình nào để kiểm thử API, UI, Mobile...).
	03. Lập trình/viết kịch bản kiểm thử (Test Script).
	04. Tạo ra tập hợp các trường hợp kiểm thử (Test Suite), kịch bản kiểm thử hoàn chỉnh (Test Scenario).
	05. Thực thi các kịch bản kiểm thử (Test Script).
	06. Ghi nhận lại kết quả và làm báo cáo.
	07. Phân tích để tìm lỗi hoặc vấn đề về hiệu năng.

==========================================================================================

[CÁC KỸ NĂNG CẦN CÓ ĐỂ KIỂM THỬ TỰ ĐỘNG]

* Danh sách các kỹ năng cần có:

	- Hiểu về các kỹ thuật kiểm thử: để thiết kế được những kịch bản kiểm thử (Test Script) một cách hiểu quả, nhằm tự động hoá quá trình kiểm thử.

	- Biết lập trình: cần có các kỹ năng về lập trình và ngôn ngữ lập trình để có thể viết được Test Script.
		+ Tuân thủ quy ước viết code.
		+ Sử dụng các công nghệ quản lý mã nguồn.

	- Rành về các Web element và Locator: giúp định vị đúng phần tử / đối tượng cần tương tác để tăng độ chính xác cho Test Script.

	- Thành thạo về một Automation Framework: sử dụng thành thạo thư viện của Selenium WebDriver API vì đây là thư viện được sử dụng phổ biến nhất trong việc kiểm thử ứng dụng web.

	- Thành thạo về một Testing Framework: hỗ trợ trong việc xây dựng framework, phân nhóm, quản lý Test Script, chuẩn bị dữ liệu, môi trường kiểm thử...

		+ Tìm hiểu về mẫu thiết kế phần mềm (Design Pattern): hỗ trợ thêm trong việc xây dựng framework.

	- Biết các câu lệnh truy vấn trong hệ quản trị cơ sở dữ liệu.

	- Hiểu biết về mô hình POM (Page - Object - Model).

	- ...

==========================================================================================

[NHỮNG LƯU Ý TRƯỚC KHI KIỂM THỬ TỰ ĐỘNG]

* Nên áp dụng kiểm thử tự động cho:
	- Các dự án lớn và trọng điểm, những dự án dài hạn và tốn nguồn nhân lực.
	- Những dự án yêu cầu kiểm thử thường xuyên trong cùng một lĩnh vực (kiểm thử lặp lại một tính năng).
	- Những yêu cầu không thường xuyên thay đổi.
	- Kiểm thử hiệu năng (Performance Testing): giả lập nhiều người sử dụng cùng một lúc,...
	- Kiểm tra tính ổn định của phần mềm trên quan điểm của kiểm thử thủ công.
	- Tính khả dụng của thời gian.
	- So sánh những điểm ảnh (pixel), màu sắc... của hình ảnh.
	- So sánh những bảng tính (spreadsheets) với rất nhiều dòng và cột.
	- Chạy song song trên nhiều trình duyệt cùng một lúc.

------------------------------------------------------------

	* Ưu tiên áp dụng cho:
		+ Những Test Case passed (Positive).
		+ Test theo thứ tự, ví dụ: đăng ký > đăng nhập > tìm kiếm > chọn mua > thanh toán.
		+ Kiểm thử giao diện (UI): phân trang, ô nhập, nút nhấn...
		+ Kiểm thử hiệu năng (Performance Testing).

--------------------------------------------------------------------------------

* Lưu ý khi lựa chọn kiểm thử tự động:
	- Chi phí khởi đầu (thuê nhân viên, mua công cụ...) cho kiểm thử tự động rất cao.
	- Kiểm thử tự động không phải là 100%, có một số trường hợp không thể kiểm thử tự động.
	- Không kiểm thử tự động với trường hợp UI không cố định.
	- Người kiểm thử tự động nên có kiến thức lập trình tốt.

==========================================================================================

[ƯU VÀ NHƯỢC ĐIỂM CỦA KIỂM THỬ TỰ ĐỘNG]

* Ưu điểm:
	- Cải thiện hiệu quả: nhanh hơn kiểm thử thủ công.
	- Cải thiện độ chính xác: đáng tin cậy hơn con người do bộ dữ liệu kiểm thử đã được chuẩn bị từ trước và đã qua quá trình kiểm tra trước khi đưa vào tự động.
	- Tính tái sử dụng cao: nếu xây dựng được một bộ framework cho riêng mình thì có thể tái sử dụng trong nhiều dự án có cùng cấu trúc (thường do một công ty thiết kế dựa trên một mẫu sẵn có).
	- Tiết kiệm được thời gian: có thể hoạt động 24/7 trong khi con người chỉ có thể bằng 50% hoặc 33% về thời gian hoạt động.
	- Giảm sự nhàm chán: cùng một Test Case nhưng có thể được thực hiện lại nhiều lần trên các loại trình duyệt khác nhau.

--------------------------------------------------------------------------------

* Nhược điểm:
	- Tốn chi phí để trả cho các công cụ tự động hoá chuyên nghiệp (phí bản quyền) và thuê nhân viên có am hiểu về kiểm thử tự động, tốn phí quản lý và bảo trì, tìm hiểu, huấn luyện / đào tạo / giáo dục...
	- Mất thời gian, công sức để tạo mới và chỉnh sửa Test Script.
	- Không phải trường hợp nào cũng phù hợp để kiểm thử tự động.
		Ví dụ: kiểm tra độ đẹp / xấu của UI...

==========================================================================================

[NHỮNG TEST CASE NÀO NÊN VÀ KHÔNG NÊN KIỂM THỬ TỰ ĐỘNG]

* Những Test Case có thể kiểm thử tự động:
	- Rủi ro cao - các Test Case quan trọng.
	- Những Test Case được thực hiện nhiều lần.
	- Những Test Case khó thực hiện thủ công.
	- Những Test Case tốn thời gian của con người.

--------------------------------------------------------------------------------

* Những Test Case không phù hợp để kiểm thử tự động:
	- Những Test Case được thiết kế mới và chưa được thực hiện thủ công ít nhất một lần.
	- Những Test Case có các yêu cầu thường xuyên thay đổi (do khách hàng chưa quyết định được tính năng, hay thay đổi yêu cầu phần mềm,...).
	- Những Test Case được thực hiện đột xuất, không có kế hoạch, kịch bản hay tài liệu tham khảo (ad-hoc). Có những Test Case khi thực thi chỉ để tạm thời giải quyết ngay vào lúc xảy ra vấn đề, không thể tổng quát hoá và tối ưu hoá thành một phương thức để áp dụng về sau này (Random/Monkey Testing).
	- Những Test Case liên tục failed.
	- Những hệ thống áp dụng quá nhiều thiết kế đồ hoạ (hiệu ứng).

==========================================================================================
==========================================================================================
==========================================================================================

[CHI TIẾT VỀ NHỮNG CÁCH THIẾT KẾ KỊCH BẢN KIỂM THỬ TỰ ĐỘNG - TEST SCRIPT]

** Có nhiều cách để thết kế kịch bản kiểm thử tự động (Test Script):

--------------------------------------------------------------------------------

	1. Code based / Script based: chủ động lập trình để định vị các thành phần (Component) / phần tử (Web element / Web control) / thẻ (Tag) trên trang web bằng cách sử dụng:
		- Bộ thư viện lập trình (Selenium, Appium...).
		- Trình điểu khiển trình duyệt trung gian (Browser WebDriver).
		- Kiến thức lập trình hướng đối tượng (OOP).
			+ Định vị các phần tử trên trang web.
			+ Tương tác với các phần tử.
			+ So sánh giá trị.
			-> Để viết Test Script (Page Object Model - POM)
			   tự động thực hiện các thao tác.
		-> Sử dụng thư viện lập trình Selenium và ngôn ngữ lập trình.
			(WebDriver)

--------------------------------------------------------------------------------

	2. Keyword based / Action based: ghi nhận lại các bước dạng kịch bản / câu lệnh Selenium (Linear: Record & Replay / Playback) bằng một phần mềm đã được viết sẵn và xây dựng thành một giao diện đồ hoạ người dùng (GUI), nhưng bản chất bên trong vẫn sẽ chứa nhiều thư viện đã được đóng gói.

		- Ban đầu sẽ thực hiện thủ công trước một lần, quá trình ghi hình (theo các bước, không phải ghi màn hình dạng video) sẽ được ngầm thực hiện song song để sau này có thể tái hiện lại các bước.

		- Trong quá trình xác định các phần tử, các phần tử sẽ được lưu vào một nơi riêng (Object Repository / Element Repository), cho phép tái sử dụng trong nhiều Test Case khác nhau.

		- Sau khi ghi nhận xong, sẽ in ra một tập các bước đã thực hiện, cho phép can thiệp và chỉnh sửa lại các bước theo phong cách kéo-thả nếu cần thiết.

		- Bên cạnh đó, các công cụ còn hỗ trợ việc chuyển các thao tác ghi nhận các bước thành ngôn ngữ lập trình (Java, C#, Python...) và cho phép chỉnh sửa lại theo phong cách lập trình.

		-> Sử dụng giao diện đồ hoạ kết hợp với ngôn ngữ lập trình.
			(Test Automation Tools / Automated Functional Testing Tools)
			- Sử dụng công cụ thuần đồ hoạ: Selenium IDE...
			- Sử dụng công cụ record + code: Katalon Studio + Katalon Recorder...
			- Sử dụng công cụ record + code + plug-in vào IDE: Telerik...

==========================================================================================

[CÁC CÔNG CỤ KIỂM THỬ TỰ ĐỘNG BẰNG ĐỒ HOẠ - AUTOMATED FUNCTIONAL TESTING TOOLS]

	* Cây DOM (Document Object Model): do trình duyệt xây dựng lên khi trang web (HTML) đã được tải về máy và nạp vào RAM thông qua quá trình duyệt / lướt web.

		- Toàn bộ các thẻ (tag) / phần tử (element) - cấu trúc trên trang web được xem là đối tượng (object) và đều thuộc lớp (class) WebElement.

		- Trong một đối tượng có thể sẽ có các đối tượng nhỏ hơn, được lồng vào bên trong.

		Ví dụ 1: đối tượng tổng chứa các đối tượng nhỏ hơn trong HTML
			<html>

				<head>
				</head>

				<body>
				</body>

			</html>

		Ví dụ 2: đối tượng tổng chứa các đối tượng nhỏ hơn trong Java

			public static Book {
				private String bookTitle;
				private ... ...;

				// Tên tác giả là một đối tượng thay vì chuỗi,
				// vì họ còn viết rất nhiều sách khác nhau
				// và có nhiều thông tin khác
				private Author author;

				...
			}

--------------------------------------------------------------------------------

** Các công cụ hỗ trợ kiểm thử tự động hai trong một - Studio (Functional Automation Testing Tools): Katalon Studio, akaAT, Telerik, Ranorex, TestComplete, Watir, HP QTP/UFT (Quick Test Professional/Unified Functional Testing)...

	- Dựa trên framework kiểm thử tự động mã nguồn mở (test automation framework) Selenium (web), Appium (desktop, mobile)...
		+ Selenium giống như một bộ thư viện, chuyên cung cấp sẵn các hàm để hỗ trợ trong việc bắt các thành phần (component) trên trang web duyệt theo cấu trúc cây DOM.

	- Sử dụng phần lõi của các thư viện thuần lập trình, nhưng sau đó đóng gói các hàm đã được làm sẵn của thư viện lại thành một ứng dụng để tiện cho việc sử dụng.

	- Lưu lại các phần tử website dưới dạng đối tượng trong Element Repository (Object Repository) và cho phép tái sử dụng trong các Test Case khác nhau của cùng một dự án.

==========================================================================================

[ĐẠI GIA ĐÌNH SELENIUM - BỘ ĐỒ NGHỀ ĐA NĂNG]

Không chỉ là một công cụ đơn lẻ, Selenium là cả một "bộ đồ nghề" (Suite / Set) với một loạt công cụ phần mềm (và thư viện) khác nhau, mỗi công cụ sẽ có những cách tiếp cận khác nhau để hỗ trợ tự động hóa trình duyệt.

	- WebDriver giống như Interface và Selenium implements các tiêu chuẩn về giao thức WebDriver của W3C, cho phép các lập trình viên tận dụng trong quá trình phát triển ứng dụng.

	- Giúp tự động mô phỏng lại những hành vi của người dùng bằng cách định vị và tương tác với các thành phần (component) / phần tử (web element) / thẻ (tag) trong trình duyệt.

	- Mục đích chính là để phục vụ việc kiểm thử tự động cho những ứng dụng web. Nhưng rộng hơn là bất kì tác vụ nào trên nền web.

--------------------------------------------------------------------------------

	[LỊCH SỬ HÌNH THÀNH - SELENIUM HISTORY]

Với tên gọi ban đầu là JavaScriptTestRunner, Selenium được phát triển bởi Jason Huggins vào năm 2004 khi ông đang làm lập trình viên tại ThoughtWorks, mục đích ban đầu của ông là phát triển một thư viện Javascript để chạy tự động các test trên nhiều trình duyệt.

Năm 2006, Simon Stewart - một nhân viên của Google tiếp tục phát triển Selenium với công việc được đặt tên là WebDriver. Nhờ có công cụ này, Google đã nhận được một lượng người sử dụng Selenium rất lớn nhưng đứng trước những hạn chế của sản phẩm thì các tester vẫn phải làm việc rất vất vả.

Năm 2008, Selenium và WebDriver chính thức được kết hợp bởi Selenium đang dần lớn mạnh và WebDriver lại là công cụ của tương lai. Với sự kết hợp này, người dùng được cung cấp một tệp những tính năng lớn.

Cái tên Selenium xuất hiện từ một trò đùa của Huggins dành cho Mercury (công ty đã từng tạo ra một framework thử nghiệm phổ biến hơn khi Selenium đang trong quá trình phát triển) - đối thủ cạnh tranh của mình.

* Tham khảo thêm:
	- https://www.selenium.dev/history/
	- https://viettuts.vn/selenium

--------------------------------------------------------------------------------

	[HỆ SINH THÁI - SELENIUM ECOSYSTEM]

Trong hơn 10 năm qua, một hệ sinh thái gồm nhiều dự án mã nguồn mở đã được xây dựng để phục vụ cho Selenium và lấy Selenium WebDriver làm trọng tâm.

------------------------------------------------------------

		[TRÌNH DUYỆT HỖ TRỢ - BROWSERS]

		Có thể hoạt động được trên nhiều trình duyệt khác nhau với những WebDriver tương ứng:

			1. Firefox: Mozilla GeckoDriver
			2. Edge: Microsoft EdgeDriver
			3. Chrome: Google ChromeDriver
			4. Opera: Opera ChromiumDriver
			5. Safari: Apple SafariDriver
			6. Internet Explorer: InternetExplorerDriver

------------------------------------------------------------

		[NGÔN NGỮ LẬP TRÌNH - LANGUAGE BINDINGS]

		Cần sử dụng một ngôn ngữ lập trình để có thể tạo ra các kịch bản (script) nhằm tương tác với Selenium Server (Remote WebDriver) hoặc tương tác với Selenium WebDriver dưới cục bộ.

			01. C#
			02. Java
			03. Python
			04. JavaScript
			05. Ruby

			06. Go
			07. Haskell
			08. Perl
			09. PHP
			10. R
			11. Dart
			12. Pharo Smalltalk

------------------------------------------------------------

		[HỆ ĐIỀU HÀNH - OPERATING SYSTEMS]

		Có thể hoạt động được trên nhiều hệ điều hành khác nhau:

			1. Microsoft Windows: tuy chỉ sử dụng những phiên bản mới nhất của hệ điều hành Windows để kiểm thử và sửa lỗi cho dự án Selenium, nhưng miễn là phiên bản của Windows còn được Microsoft hỗ trợ, thì chắc chắn sẽ sử dụng được Selenium.

			2. macOS: dù dạo gần đây không từng sử dụng bất kỳ phiên bản nào của macOS để kiểm thử cho dự án Selenium, nhưng vẫn có hỗ trợ phiên bản ổn định và thường không phải là phiên bản mới nhất.

			3. Linux: Ubuntu là nền tảng kiểm thử chính của dự án Selenium, nhưng những biến thể khác của Linux vẫn sẽ hoạt động tốt miễn là các nhà phát hành trình duyệt còn hỗ trợ.

------------------------------------------------------------

		[FRAMEWORKS]

		Programming languages are supported through Selenium drivers. These are libraries made for each language that expose commands from the Selenium API natively in the form of methods/functions.

		Selenium is often used for automating web applications for testing purposes, but it does not include a testing framework. Some testing frameworks that can be used with Selenium are listed below.

			- Ruby:
				+ Watir
				+ Capybara

			- JavaScript:
				+ WebdriverIO
				+ CodeceptJS
				+ Nightwatch.js

			- Java:
				+ FluentLenium
				+ QAF
				+ Selenide

			- Python:
				+ Helium
				+ Nerodia
				+ SeleniumBase

--------------------------------------------------------------------------------

	[CÁC THÀNH PHẦN - SELENIUM COMPONENTS]

* Tham khảo thêm: https://www.selenium.dev/documentation/overview/components/

--------------------------------------------------------------------------------

	[CÁC DỰ ÁN SELENIUM - SELENIUM PROJECTS]

	* Tài nguyên kiểm thử:
		1. Kịch bản kiểm thử tự động (Test scripts): Mã nguồn để kiểm thử trình duyệt và so sánh kết quả.

		2. Dữ liệu kiểm thử (Test data): Những dữ liệu được sử dụng trong những tình huống, ngữ cảnh khác nhau.

		3. Cấu hình kiểm thử (Test configuration): Các tập tin cấu hình liên quan đến môi trường kiểm thử (ví dụ: đường dẫn trang web, trình duyệt đang sử dụng...).

		4. Báo cáo kiểm thử (Test reporting): Những báo cáo thu được sau khi thực thi kiểm thử, nêu chi tiết kết quả kiểm thử: thành công, thất bại và bỏ qua...

		5. Công cụ hỗ trợ kiểm thử (Test utilities): Chứa các lớp và hàm được xây dựng sẵn để tái sử dụng trong những trường hợp lặp lại (ví dụ: tương tác với những phần tử quen thuộc, xử lý lỗi...).

Là một "bộ sưu tập đồ nghề" với nhiều công cụ khác nhau, mỗi công cụ sẽ đáp ứng từng nhu cầu kiểm thử khác nhau. Là sự kết hợp của nhiều dự án khác nhau để tạo thành một hệ thống kiểm thử đa năng.
	- Được gọi là một Framework vì có cung cấp đẩy đủ các loại công cụ, thư viện và các hướng dẫn để quản lý dự án kiểm thử.
	- Tạo ra một quy chuẩn cần phải tuân theo để quản lý mã nguồn một cách hiệu quả (ví dụ: các tập tin nên được phân chia như thế nào...).
	- Giúp những tài nguyên kiểm thử cũng dễ dàng hơn trong việc bảo trì, mở rộng và tái sử dụng theo thời gian.

	-> Tiêu chuẩn hoá cách thức tổ chức mã nguồn.

Nhưng cần lưu ý, bản thân Selenium lại không phải là một Testing Framework.
	- Vì vậy, để sử dụng thêm một số tính năng nâng cao, ta cần sử dụng thêm một số Testing Framework để hỗ trợ như: TestNG, JUnit, NUnit, PyUnit, Cucumber...
	- Những tính năng đó có thể là:
		- Gom nhóm và sắp xếp độ ưu tiên cho các tình huống kiểm thử.
		- Thực hiện kiểm thử hướng dữ liệu (DDT).
		- Kiểm thử song song trên nhiều trình duyệt.
		- Thực thi hàng loạt, so sánh và báo cáo kết quả kiểm thử...
		- Tập hợp những cú pháp (annotations) để cung cấp dữ liệu, khai báo sự phụ thuộc lẫn nhau giữa các tình huống kiểm thử, 

* Bộ đồ nghề Selenium (Selenium Suite) bao gồm:

------------------------------------------------------------

	1. Selenium IDE: với tên cũ là Selenium Recorder và được ra mắt vào năm 2006.

		- Đây là một tiện ích mở rộng (Plug-in / Add-on / Extension), ban đầu chỉ có thể sử dụng được trên trình duyệt Firefox, nhưng sau đó đã mở rộng ra và có thể sử dụng trên Chrome và Edge.

		- Hỗ trợ ghi nhận lại các bước dạng kịch bản (Record & Replay / Playback) và quản lý theo bộ (Suite), giúp tự động mô phỏng lại những thao tác của người dùng trên trình duyệt.

		- Thường được sử dụng để tạo ra những đoạn kịch bản (Selenium Script) đơn giản hoặc để kiểm thử thăm dò (Exploratory Testing) mà không cần phải có quá nhiều kiến thức về lập trình.

		-> Tiện ích mở rộng trên trình duyệt, giúp ghi nhận lại các bước dạng kịch bản.

		* Selenese / Selenium command: là ngôn ngữ miền chuyên biệt / ngôn ngữ đặc tả chuyên biệt (Domain-specific language - DSL) của Selenium IDE. Selenese cung cấp một tập hợp gồm nhiều câu lệnh (Action, Accessor và Assertion), được sử dụng để tự động hoá các tương tác trên web.
			-> Ngôn ngữ đặc biệt để viết Test Script của Selenium IDE.

			(* Tham khảo thêm: https://www.selenium.dev/documentation/legacy/selenium_ide/#selenium-commands--selenese)

------------------------------------------------------------

	2. Selenium RC (Remote Control) / (Selenium 1): phiên bản đầu tiên của Selenium, được ra mắt vào năm 2004.

		- Selenium Remote Control (RC) là một Server ảo được viết bằng Java, làm trung gian giao tiếp giữa người dùng và trình duyệt bằng cách nhận các câu lệnh, phiên dịch và báo cáo kết quả của việc thực thi.

		-> Sử dụng ngôn ngữ lập trình để điều khiển trình duyệt, Selenium Remote Control sẽ làm Server ảo trung gian.

------------------------------------------------------------

	3. Selenium WebDriver - 2/3/4: phiên bản nâng cấp của Selenium RC (hợp nhất Selenium RC và Selenium WebDriver), ra mắt vào năm 2009.

		- Phần lõi (core) của Selenium chính là Selenium WebDriver.

		- Là một interface và cho phép người dùng viết code để làm việc trực tiếp với trình duyệt ở mức độ hệ điều hành mà không cần đến Server ảo nữa.

		- Cung cấp API đa trình duyệt (cross-browser API), cho phép điều khiển nhiều trình duyệt khác nhau bằng nhiều ngôn ngữ lập trình khác nhau.

		- Công dụng chính của Selenium WebDriver là tự động hoá việc kiểm thử trên các ứng dụng web.

		-> Cung cấp các hàm và cho phép sử dụng ngôn ngữ lập trình để điều khiển trình duyệt.

------------------------------------------------------------

	4. Selenium Grid: được ra mắt vào năm 2008.

		- Selenium Hub là tính năng dùng để chạy Test Script một cách phân tán và song song trên nhiều máy tính - WebDriver node (khi cần chạy Test Script trên nhiều hệ điều hành, trình duyệt / phiên bản của trình duyệt...) mà không cần phải chỉnh sửa lại Test Script, đã được code sẵn trong Selenium, chỉ việc lấy và sử dụng.

		- Mục đích chính là để giảm thời gian thực hiện và tăng phạm vi thử nghiệm.

		-> Chạy Test Script cùng một lúc trên nhiều tổ hợp máy, hệ điều hành, trình duyệt và phiên bản khác nhau.

		(* Tham khảo thêm: https://vananhtooo.wordpress.com/2017/09/26/selenium-grid-la-gi/)

(* Tham khảo thêm: https://en.wikipedia.org/wiki/Selenium_(software))

--------------------------------------------------------------------------------

	[TÓM TẮT VỀ SELENIUM]

* Tóm tắt về Selenium:
	- Là một dự án ô mã nguồn mở.
	- Chuyên được sử dụng để tự động hoá kiểm thử cho ứng dụng web.
	- Hoạt động được trên nhiều trình duyệt và nền tảng: Microsoft Windows, macOS, Linux.
	- Hỗ trợ nhiều ngôn ngữ lập trình: C#, Java, Python, JavaScript, Ruby...

Tuỳ thuộc vào ngữ cảnh mà Selenium có thể là:
	- Công cụ. (chính thống, chỉ phục vụ cho nền tảng web)
	- Framework.
	- Thư viện. (có thể được import vào trong một project để sử dụng)

==========================================================================================
==========================================================================================
==========================================================================================

[SỬ DỤNG IDE ĐỂ GHI NHẬN KỊCH BẢN KIỂM THỬ TỰ ĐỘNG]

Bản chất bên trong của những công cụ IDE vẫn là Selenium WebDriver, nhưng thay vì được gói thành một thư viện lập trình thì sẽ được gói thành cả một ứng dụng và hỗ trợ tương tác thông qua giao diện đồ hoạ.

** Sử dụng công cụ để ghi nhận lại các bước dạng kịch bản (Record & Replay / Playback):

--------------------------------------------------------------------------------

	Bước 01: Truy cập các trang chủ của Selenium IDE hoặc trang cửa hàng trực tuyến của trình duyệt (ví dụ: Chrome Web Store, Firefox Add-ons, Microsoft Edge Add-ons...) để tải tiện ích mở rộng về và cài đặt vào trình duyệt.
		| https://www.selenium.dev/selenium-ide/

--------------------------------------------------------------------------------

	Bước 02: Tạo mới một dự án để chứa nhiều Test Script bên trong bằng tuỳ chọn "Create a new project" và đặt tên cho dự án.

--------------------------------------------------------------------------------

	Bước 03: Nhấn vào nút [+], tạo mới một Test Case bằng tuỳ chọn "Add new test" và đặt tên cho Test Case (thuộc về một dự án).
		(Giống như việc tạo mới và đặt tên cho hàm.)

--------------------------------------------------------------------------------

	Bước 04: Dán URL của trang web muốn kiểm thử vào thanh địa chỉ "Playback base URL".

		// Tương đương với các câu lệnh (Java) của Selenium WebDriver
			| WebDriver myBrowser = new ChromeDriver();
			| myBrowser.get("https://google.com");

		* Lưu ý: Đường dẫn bắt buộc phải có thêm "https://" để tránh bị lỗi ERR_FILE_NOT_FOUND (Your file couldn’t be accessed - It may have been moved, edited, or deleted.).

--------------------------------------------------------------------------------

	Bước 05.01: Sử dụng tính năng ghi nhận (Record).

		1. Tại giao diện của Selenium IDE, bấm nút [Start recording] ở góc trên-bên phải hoặc sử dụng phím tắt [Ctrl] + [U] để bắt đầu ghi nhận lại (Record) toàn bộ những thao tác đã thực hiện thủ công theo một tình huống mong muốn.

			[Khi trình duyệt được mở lên, ở góc dưới-bên phải sẽ hiển thị dòng chữ "Selenium IDE is recording".]

		2. Thao tác theo theo Test Case đã được thiết kế.

		3. Sau khi hoàn thành các thao tác, quay trở lại giao diện của Selenium IDE và nhấn nút [Stop recording] hoặc sử dụng phím tắt [Ctrl] + [U] một lần nữa.

		4. Đặt tên cho Test Script vừa thao tác và được tạo tự động xong.

		5. Các thao tác thủ công đã được ghi nhận lại theo từng bước. Lúc này, ta có thể chỉnh sửa lại theo ý muốn và loại bỏ đi những thao tác thừa (ví dụ: Nhấn chuột, phóng to màn hình...).

		6. Nhấn nút [Run current test] để mô phỏng lại (Replay / Playback) theo đúng những gì đã ghi nhận (Record) mỗi khi có nhu cầu thực thi Test Script.

------------------------------------------------------------

	Bước 05.02: Viết mã để thực hiện.

		- Command: chứa các lệnh đã được thiết kế sẵn, ta chỉ việc chọn để tạo Test Script hoặc thậm chí là tự khai báo biến để sử dụng riêng.

		- Target: áp dụng thêm cách kỹ thuật locator để chỉ định chính xác vị trí của thành phần / đối tượng cần tương tác.

		- Value: đặt giá trị cho thành phần / đối tượng chỉ định trong Target nếu cần (ví dụ: giá trị cho ô textbox...) để làm dữ liệu đầu vào, dữ liệu so sánh...

--------------------------------------------------------------------------------

	Bước 06: [Tuỳ chọn] Một số thao tác có thể sử dụng trong quá trình kiểm thử trang web bằng Selenium IDE.

		- So sánh (Assert) hoặc kiểm tra (Verify) các phần tử.
			| Trỏ chuột hoặc quét chọn trên trang web
			| > Chuột phải > Selenium IDE > Assert / Verify

		- Điều chỉnh tốc độ thực thi của Test Case bằng nút [Test execution speed].

		- Chuyển đổi các kịch bản trên IDE thành mã lập trình với nhiều ngôn ngữ lập trình khác nhau + Unit Testing Framework tương ứng (ví dụ: C# NUnit, Java JUnit...).
			| Trỏ chuột vào tên Test Case > [⋮] > [Export]

			// Tích chọn các tuỳ chọn:
				[✓] Include origin tracing code comments
				[✓] Include step description as a separate comment
				[ ] Export for use on Selenium Grid

==========================================================================================

[XÁC MINH TRONG SELENIUM IDE VỚI ASSERT VÀ VERIFY]

* Assert: nếu trong quá trình thực thi Test Case mà trả về kết quả so sánh là fail, lập tức dừng ngay việc test và tất cả các Test Case còn lại chưa được thực thi đều cũng sẽ bị dừng.
	-> So sánh và dừng nếu fail.

--------------------------------------------------------------------------------

* Verify (Soft Assert): vẫn tiếp tục thực hiện kiểm thử tất cả các Test Case khác dù có Test Case trả về kết quả fail, ta sẽ nhận được danh sách kết quả sau khi tất cả các Test Case thực hiện xong bằng cách gọi hàm assertAll().
	-> Chỉ kiểm tra chứ không dừng nếu fail.

==========================================================================================
==========================================================================================
==========================================================================================

[SỬ DỤNG WEBDRIVER ĐỂ THIẾT KẾ KỊCH BẢN KIỂM THỬ TỰ ĐỘNG]

	* W3C (World Wide Web Consortium): tổ chức tiêu chuẩn quốc tế chính cho World Wide Web. Hiệp hội này chuyên phát triển và đề xuất các tiêu chuẩn cho World Wide Web, giúp chuẩn hoá các khái niệm liên quan đến web - Tổ chức quốc tế quản lý sự phát triển web và sự phát triển của các công nghệ có thể tương tác để phát huy hết tiềm năng của Web.

Có nhiều hãng thiết kế trình duyệt web (Mozilla, Google, Apple, Microsoft...) với những trình duyệt khác nhau, nhưng tất cả đều tuân thủ và thiết kế theo tiêu chuẩn do W3C đã đưa ra, từ đó giúp dễ dàng hơn trong việc tương thích.

	Ví dụ: để cạnh tranh, các trình duyệt khác nhau quyết định hỗ trợ những bộ thẻ khác nhau, gây khó khăn cho các lập trình viên, khiến một số website chỉ hoạt động tốt ở một số trình duyệt nhất định.
		-> W3C giúp chuẩn hoá và thống nhất trong thiết kế trình duyệt.

Mặc định, trình duyệt sẽ được người dùng điều khiển thông qua các ô nhập, nút nhấn, mở tab mới, lưu dấu trang, xoá dữ liệu duyệt web... Nhưng trong bộ tiêu chuẩn khi thiết kế trình duyệtcủa W3C có một tiêu chuẩn mang ý nghĩa rằng: "Mọi trình duyệt nên cho phép lập trình viên can thiệp, điều khiển được hoạt động của trình duyệt thông qua code khi trình duyệt đang chạy", để giúp cho QC tự động hoá quá trình kiểm thử website dưới góc nhìn của người dùng.

	- Phần "hậu trường" của một trang web cũng chỉ là các thẻ (tag) / phần tử (element) / thành phần (component) và bên trong chứa những giá trị, thuộc tính...
	
	- Vì vậy, bên cạnh việc thao tác thủ công trên màn hình giao diện, ta hoàn toàn có thể viết code để tự động hóa được quá trình kiểm thử.

	- Lúc này, trình duyệt chính là một đối tượng (object), cung cấp các hàm cho các lập trình viên và cho phép tương tác thông qua việc gọi hàm.

	Ví dụ: Giống như việc truyền hình luôn cho phép người dùng can thiệp trong phạm vi cho phép bằng điều khiển từ xa.
		- Chiếc điều khiển từ xa được xem như một đối tượng.
		- Những nút bấm trên điều khiển được xem như những hàm.

	-> Hỗ trợ kiểm thử bằng cách cho phép code đóng vai người dùng để sử dụng trình duyệt.

------------------------------------------------------------

* Tham khảo thêm:
	- https://w3c.github.io/webdriver/
	- https://www.w3.org/TR/webdriver/

--------------------------------------------------------------------------------

[KIẾN TRÚC CỦA SELENIUM WEBDRIVER]

Selenium WebDriver là thư viện lập trình được sử dụng để điều khiển trình duyệt web.
	- Cho phép sử dụng nhiều ngôn ngữ lập trình khác nhau (ví dụ: Java, JavaScript, Python, C#...) để điều khiển nhiều loại trình duyệt khác nhau (ví dụ: Chrome, Edge, Firefox...).
	- Mục đích chính là để tự động hoá việc kiểm thử các ứng dụng web.

Nhưng nếu muốn sử dụng được Selenium WebDriver để tự động hoá, cần thêm sự giúp sức đến từ chính những nhà phát triển trình duyệt.

	- Cụ thể, mỗi nhà phát triển trình duyệt sẽ cung cấp riêng một tập tin nhị phân tương ứng, được gọi là trình điều khiển trình duyệt (Browser WebDriver), để làm trung gian kết nối giữa Selenium WebDriver và trình duyệt.
		Ví dụ: Các nhà phát triển trình duyệt và trình điều khiển trình duyệt của họ.
			Google Chrome -> ChromeDriver
			Mozilla Firefox -> GeckoDriver
			Microsoft Edge -> MsEdgeDriver
			...

	- Khi sử dụng trình điều khiển trình duyệt (do nhà phát triển trình duyệt cung cấp) làm trung gian:
		+ Bắt đầu từ Selenium 4, kết nối giữa Selenium và trình điều khiển trình duyệt sẽ thông qua chuẩn giao thức W3C WebDriver (còn ở Selenium 3 sẽ là JSON Wire Protocol).
		+ Còn kết nối giữa trình điều khiển trình duyệt và trình duyệt sẽ thông qua tính năng được tích hợp sẵn trong mỗi trình duyệt.

------------------------------------------------------------

** Kiến trúc của Selenium WebDriver (Selenium 3):

	Python			Selenium		GeckoDriver		FireFox
	Java			client			ChromeDriver		Chrome
	C#			library			SafariDriver		Safari


								  HTTP over HTTP Server
								-------------------------
								|			|
								|			v
----------------------    ----------------------    ---------------------    ---------------
| Ngôn ngữ lập trình |--->| Thư viện lập trình |--->| Trình điều khiển	|--->| Trình duyệt |
----------------------    ----------------------    ---------------------    ---------------
								^			|
								|			|
			    JSON Wire Protocol			-------------------------
			    Over HTTP				  HTTP over HTTP Server
			 (Không còn được sử dụng
			  ở Selenium 4,
			  mà thay vào đó là
			  W3C WebDriver)


// Có thể hình dung:

Java, C#... -------------> JDBC, ADO.NET --------------------> Database Engine: SQL Server,
										Oracle, MySQL
			   (Vừa kết nối với Database Engine,
			    vừa cung cấp bộ thư viện
			    để lập trình)

--------------------------------------------------------------------------------

[NHỮNG CÔNG CỤ CẦN PHẢI CÓ ĐỂ ĐIỀU KHIỂN TRÌNH DUYỆT]

Đối với người dùng, việc tương tác với trình duyệt sẽ chỉ đơn giản là thông qua giao diện, vì trình duyệt được thiết kế để họ dễ dàng sử dụng.

Nhưng đối với các kiểm thử viên tự động (Automation Tester), với nhu cầu kiểm thử một ứng dụng web, để tương tác và điều khiển được trình duyệt thông qua ngôn ngữ lập trình, thì phải sử dụng thêm cầu nối trung gian (trình điều khiển - driver - thư viện), giúp giao tiếp với trình duyệt thật sự.

** Quy trình viết kịch bản kiểm thử tự động bằng việc chủ động lập trình:

------------------------------------------------------------

	[1. BỘ THƯ VIỆN LẬP TRÌNH SELENIUM - SELENIUM WEBDRIVER API]

	* Client library / Client library API: cung cấp API để giao tiếp giữa ngôn ngữ lập trình và WebDriver.
		- Cho phép sử dụng ngôn ngữ lập trình để chạy các lệnh Selenium bằng cách cung cấp một loạt các hàm thông qua API.
		- Mỗi ngôn ngữ lập trình khác nhau sẽ có gói thư viện khác nhau.
		- Có nhiệm vụ nhận các câu lệnh và đưa sang cho Selenium Server để tiến hành kiểm thử, đồng thời cũng sẽ nhận các kết quả trả về và trả về cho ứng dụng. Ứng dụng sẽ lưu kết quả xử lý vào một biến và kiểm tra xem thành công hay thất bại.

----------------------------------------

** Thư viện lập trình (Selenium WebDriver API): để điều khiển được trình duyệt thì bắt buộc phải sử dụng code, kèm theo đó là những thư viện được gói trong package / namespace và chuyên cung cấp các hàm phục vụ cho việc lập trình.

	- Là tập hợp gồm nhiều lớp (class) trừu tượng, hay còn được gọi là Interface, được đóng gói theo một định dạng cụ thể (*.jar, *.dll, *.exe...).
		+ Chuyên cung cấp các lệnh (API), cho phép lập trình viên sử dụng những ngôn ngữ lập trình khác nhau như: Java, Python, C#, Ruby...
		+ Nói cách khác, đối tượng được tạo ra từ Selenium WebDriver sẽ làm đại diện cho một đối tượng (object) trình duyệt và cung cấp các lệnh / hàm.
	
	- Vì đã là thư viện nên cách sử dụng cũng sẽ giống hệt như mọi thư viện khác trong ngôn ngữ lập trình, phải tải về và thêm thủ công vào dự án hoặc khai báo tên thư viện theo dạng phụ thuộc (Dependency).

	- Khi chạy Test Script, Selenium WebDriver sẽ gọi trực tiếp (direct call) cho trình duyệt thông qua chính trình điều khiển trình duyệt (Browser WebDriver) mà nhà phát triển trình duyệt đấy cung cấp. Sau đó, các hành động trong Test Script sẽ được thực thi.

	-> Cung cấp API và cho phép điều khiển nhiều trình duyệt khác nhau bằng nhiều ngôn ngữ lập trình khác nhau.

		* Chi tiết lời gọi trực tiếp (direct call):

			1. Với mỗi một hành động từ Test Script, một thông điệp HTTP Request sẽ được tạo ra để gửi các yêu cầu từ Client lên Server.

			2. HTTP Request đó sẽ được gửi đến trình điều khiển trình duyệt.

			3. Mỗi trình điều khiển trình duyệt sẽ có một HTTP Server để tiếp nhận HTTP request.

			4. Sau khi nhận được thông điệp, HTTP Server xác định những bước cần thiết để thực thi hành động phản hồi lại yêu cầu.

			5. HTTP Server mô phỏng lại các thao tác theo đúng những bước đã được thiết kế trong Test Script.

			6. Sau đó, HTTP Server trả lại trạng thái thực hiện những hành động cho Client, nơi đang thực thi Test Script.

------------------------------------------------------------

	[2. TRÌNH ĐIỀU KHIỂN TRÌNH DUYỆT - BROWSER WEBDRIVER / PROXY]

	* Protocol: giao thức chung (giống như ngôn ngữ trung gian) để giúp Selenium WebDriver và trình duyệt có thể hiểu nhau. Trình điều khiển trình duyệt sẽ hiểu giao thức và từ đó giúp giao tiếp được với Selenium WebDriver.

	* JSON Wire Protocol: giao thức này sẽ không còn được hỗ trợ kể từ Selenium 4.

	* WebDriver W3C: giao thức mới thay thế cho JSON Wire Protocol.

	(* Tham khảo thêm:
		- https://anhtester.com/blog/nhung-tinh-nang-moi-trong-selenium-4-b464.html
		- https://youtu.be/6iHdvOYdJk8 - Selenium 4 with Simon Stewart and BrowserStack)

----------------------------------------

** Trình điều khiển trình duyệt (Browser WebDriver): vì theo quy chuẩn của W3C thì trình duyệt phải được thiết kế mở, đi kèm với trình duyệt sẽ là một "người anh em song sinh", rất am hiểu vể trình duyêt nên có thể điều khiển được trình duyệt.

	- Bản thân trình duyệt là một thế giới riêng và rất phức tạp, người sử dụng thông thường sẽ không thể can thiệp trực tiếp thông qua code được.
		+ Và để đảm bảo tính trừu tượng (Abstraction) của việc thiết kế mà những thư viện lập trình (Selenium) cũng không được trực tiếp can thiệp vào trình duyệt.
		+ Vì vậy, trình điều khiển trình duyệt sẽ làm cầu nối trung gian và đảm nhận việc tương tác giữa trình duyệt và thư viện lập trình (Selenium).

	- Trình điều khiển trình duyệt đóng vai trò làm cầu nối trung gian (giống như Proxy) - Interface để kết nối giữa trình duyệt thực tế và thư viện lập trình.
		+ Là một ứng dụng do chính nơi phát triển trình duyệt tạo ra để bên ngoài có thể tương tác với trình duyệt của họ.
		+ Đến từ nhiều nhà phát triển khác nhau với những cái tên khác nhau, bao gồm: ChromeDriver, OperaDriver, GeckoDriver...
		+ Có nhiệm vụ nhận các câu lệnh do thư viện lập trình (Selenium) gửi, sau đó thao tác lại trên trình duyệt thật.		

	- Bộ quy chuẩn chung được tách riêng cho khỏi trình duyệt. Là đoạn code chạy song song với trình duyệt, có kết nối với thư viện lập trình (Selenium), từ đó cho phép ngôn ngữ lập trình (Python, Java, C#...) can thiệp vào trình duyệt để kiểm thử những ứng dụng web một cách tự động bằng code.

	- Việc giao tiếp giữa thư viện lập trình Selenium WebDriver API và trình điều khiển trình duyệt sẽ được thực hiện thông qua giao thức W3C WebDriver (tên cũ là JSON Wire Protocol)

	-> Tập tin nhị phân biết cách giao tiếp với trình duyệt và thư viện lập trình.

(* Tham khảo thêm: https://www.selenium.dev/documentation/webdriver/)

------------------------------------------------------------

	[3. TRÌNH DUYỆT VẬT LÝ / THỰC SỰ - BROWSER]

** Trình duyệt (Browser): giúp đưa con người đến mọi nơi trên internet, cho phép họ xem văn bản, hình ảnh và video từ mọi nơi trên thế giới.

	- Với triết lý thiết kế "evergreen", các trình duyệt hiện đại sẽ được tự động cập nhật phiên bản mới nhất.
		+ Người dùng luôn luôn được trải nghiệm những tính năng và bản vá bảo mật mới nhất.
		+ Đồng thời, trình duyệt sẽ luôn hỗ trợ các tiêu chuẩn và công nghệ web mới nhất, giúp các nhà phát triển web có thể tận dụng được những tính năng này để xây dựng các ứng dụng web phức tạp với các tính năng và chức năng nâng cao, không cần lo về việc ứng dụng web của mình phải tương thích với các trình duyệt cũ hơn vì mặc định trình duyệt của người dùng cũng đang ở phiên bản mới nhất.

	- Vì những phiên bản khác nhau của cùng một trình duyệt đã có thể khác nhau về câu lệnh, nên yêu cầu phải có sự đồng bộ / tương thích giữa hai phiên bản của trình duyệt và trình điều khiển trình duyệt.

	- Việc đồng bộ phiên bản sẽ giúp tránh gặp những lỗi không mong muốn phát sinh trong quá trình thiết kế và thực thi Test Script.
		Ví dụ: lỗi "This version of ChromeDriver only supports Chrome version 1xx"

	-> Nơi mọi thao tác của con người sẽ diễn ra (cần có một trình điều khiển trình duyệt với phiên bản phù hợp để tương tác).

==========================================================================================

[CÁC BƯỚC CƠ BẢN CẦN THỰC HIỆN ĐỂ THIẾT KẾ KỊCH BẢN KIỂM THỬ TỰ ĐỘNG]

** Các yêu cầu để viết kịch bản kiểm thử (Test Script):

	1. Thư viện lập trình (Selenium Automation Framework): Selenium (tuỳ vào ngôn ngữ lập trình).

	2. Trình điều khiển trình duyệt (Browser WebDriver): phần trung gian để kết nối với trình duyệt, thay con người điều khiển trình duyệt.

	3. Trình duyệt (Browser): Để tiện cho việc học tập và nghiên cứu, có thể chọn những trình duyệt ít phát hành phiên bản cập nhật (ví dụ: Firefox...).

(* Tham khảo thêm:
	- https://www.selenium.dev/documentation/webdriver/getting_started/install_library/
	- https://giangtester.com/bai-1-selenium-webdriver-la-gi/)

--------------------------------------------------------------------------------

	[THIẾT KẾ KỊCH BẢN KIỂM THỬ VỚI SELENIUM WEBDRIVER]

	(Hướng dẫn thao tác trên hệ điều hành Windows
	 với ngôn ngữ lập trình Java & Python,
	 sử dụng trình duyệt Google Chrome | Lõi (Kernel): Chromium)

** Các bước viết code (Test Script) để tự động hoá những thao tác của QC / Người dùng khi sử dụng một website (điều khiển trình duyệt) bằng Selenium WebDriver:

------------------------------------------------------------

	Bước 00: Tải trình duyệt và đảm bảo trình duyệt đã được cài ở đường dẫn mặc định (C:\Program Files\Google\Chrome\Application\).

		- Có thể kiểm tra bằng cách gõ trực tiếp đường dẫn "chrome://version/" vào trình duyệt.

		- Nếu không cài ở đường dẫn mặc định, ta vẫn có thể yêu cầu ChromeDriver sử dụng đường dẫn tuỳ chọn: https://chromedriver.chromium.org/capabilities

------------------------------------------------------------

	Bước 01: Kiểm tra phiên bản hiện tại của trình duyệt và sau đó tải xuống ChromeDriver (tập tin nhị phân *.exe) tương ứng với phiên bản (và kiến ​​trúc) đang sử dụng.

		1. Kiểm tra phiên bản của trình duyệt:
			Help -> About Google Chrome
			(Hoặc sử dụng: chrome://version/)

		2. Tải phiên bản ChromeDriver tương ứng với phiên bản hiện tại của trình duyệt.
			- https://chromedriver.chromium.org/downloads
			- https://chromedriver.storage.googleapis.com/index.html

------------------------------------------------------------

	Bước 02: Tải thư viện Selenium WebDriver và những thư viện phụ thuộc đi kèm khác, tương ứng với ngôn ngữ lập trình.

		* Java:
			+ Ant: https://github.com/SeleniumHQ/selenium/releases/
			+ Maven: https://mvnrepository.com/artifact/org.seleniumhq.selenium/selenium-java

			// Có thể chỉ cần tải riêng một số thư viện như: Selenium API, Selenium Chrome Driver, Selenium Chromium Driver...

------------------------------------------------------------

	Bước 03: Cho Selenium WebDriver biết tập tin ChromeDriver nằm ở đâu trong máy tính.
			- Tạo mới một dự án và sao chép tập tin ChromeDriver.exe vào trong cùng thư mục chứa dự án hoặc bất kì đường dẫn nào mà ta mong muốn, sau đó khai báo đường dẫn vào trong biến môi trường ảo (JVM - Java, venv - Python...).
			- Nếu để trong cùng thư mục với dự án sẽ giúp dễ quản lý khi đưa lên Server (ví dụ: GitHub...) và sử dụng mà không cần khai báo đường dẫn quá dài. Ngược lại, nếu để ở nơi khác không cùng với thư mục chứa dự án thì phải chỉ rõ đường dẫn hoặc khai báo biến môi trường.

			* Java:
				// * Cách: Sử dụng biến môi trường ảo

				//	Trình điều khiển trình duyệt
				//	sẽ nằm ngay trong thư mục chứa dự án
				String duongDanChuaBrowserWebDriver = "chromedriver.exe";
				//	-> Khai báo đường dẫn chứa trình điều khiển trình duyệt

				// Nếu để ở nơi khác thì phải khai báo đầy đủ đường dẫn
				//  Ví dụ: "D:\\swt\\project\\chromedriver.exe"
				//
				// (Sử dụng hai dấu xuyệt phải (dấu chéo ngược) '\\'
				//  để tránh những ký hiệu đặc biệt trong lập trình,
				//  ví dụ: '\n' để xuống hàng)

------------------------------------------------------------

	Bước 04: Báo cho máy ảo biết có một biến môi trường đặc biệt.

		Cách 1: Sử dụng biến môi trường Path trong hệ điều hành để lưu đường dẫn đến tập tin ChromeDriver.
			| System variables > Path > Edit > ...

		Cách 2: Sử dụng biến môi trường ảo của ngôn ngữ lập trình để lưu đường dẫn đến tập tin ChromeDriver.
			- Không chỉ riêng hệ điều hành mới có biến môi trường, máy ảo cũng giống như một hệ điều hành độc lập và cũng có riêng cho mình một biến môi trường.
			- Selenium có thể dụng biến môi trường của hệ điều hành hoặc sử dụng biến môi trường của máy ảo.
			- Nếu sử dụng biến môi trường của máy ảo, phải thiết lập đường dẫn kết nối đến ChromeDriver.exe bằng một phương thức nào đó trong lập trình (ví dụ: phương thức setProperty() trong Java...).

		* Java:
			// * Chỉ thực hiện cách này
			//   khi không khai báo ChromeDriver
			//   trong biến môi trường của hệ điều hành

			//	Thông qua phương thức setProperty(),
			//	báo cho máy ảo Java biết rằng
			//	có một biến môi trường (dành riêng cho máy ảo)
			//	với tên biến là "webdriver.chrome.driver"
			//	và trỏ đến giá trị là đường dẫn
			//	được chứa bên trong biến chuỗi
			//	"duongDanChuaBrowserWebDriver" ở bên trên

			System.setProperty("webdriver.chrome.driver", duongDanChuaBrowserWebDriver);
			//	-> Thiết lập biến môi trường
			//	   và ánh xạ đến đường dẫn ChromeDriver
			//		(webdriver.chrome.driver ≈ JAVA_HOME)
			//		(C:\Selenium\Drivers     ≈ C:\Program Files\Java\jdk)

			// System.setProperty("webdriver.gecko.driver", "geckodriver.exe");
			// System.setProperty("webdriver.edge.driver", "msedgedriver.exe");
			// System.setProperty("webdriver.opera.driver", "operadriver.exe");
			// System.setProperty("webdriver.ie.driver", "IEDriverServer.exe");

		* Python:
			trinh_dieu_khien_trinh_duyet = webdriver.Chrome('chromedriver.exe')

------------------------------------------------------------

	Bước 05: Nhưng trước khi thật sự mở trình duyệt lên và tự động điều khiển trình duyệt.
		- Giống như việc truy cập phần cài đặt của trình duyệt và thiết lập một số tuỳ chọn cho trình duyệt, lập trình viên cũng có thể cấu hình thêm các tuỳ chọn trước khi mở trình duyệt thông qua code.
		- Việc tuỳ chỉnh các thiết lập của trình duyệt Chrome sẽ được thực hiện thông qua hàm addArguments() thuộc lớp ChromeOptions.
		- Một số thiết lập phổ biến:
			+ Tuỳ chỉnh ngôn ngữ.
			+ Cài tiện ích mở rộng.
			+ Sử dụng chế độ ẩn danh.
			+ Tuỳ chỉnh kích thước của cửa sổ.
			+ ...

		* Java:
			// Khai báo thư viện
			// tương ứng với trình duyệt đang sử dụng
			import org.openqa.selenium.chrome.ChromeOptions;

			ChromeOptions tuyChonTrinhDuyet = new ChromeOptions();

			// Kích hoạt tính năng CORS để cho phép WebDriver
			// có thể can thiệp và điều khiển từ xa
			tuyChonTrinhDuyet.addArguments("--remote-allow-origins=*");

			// Mở trình duyệt ở chế độ ẩn danh
			tuyChonTrinhDuyet.addArguments("--incognito"); 

			// Ngôn ngữ mặc định (giao diện) là tiếng Anh
			tuyChonTrinhDuyet.addArguments("--lang=en-GB");
			
			// Mở rộng hết cỡ kích thước của cửa sổ trình duyệt
			tuyChonTrinhDuyet.addArguments("--start-maximized");
			...

			// Cài đặt thêm tiện ích mở rộng cho trình duyệt
			tuyChonTrinhDuyet.addExtensions(...);

------------------------------------------------------------

	Bước 06: Chính thức sử dụng đối tượng đại diện trong trình duyệt để gọi trình duyệt lên và tiến hành một số tuỳ chỉnh cho trình duyệt (nếu có).

		- Khi duyệt web, bản thân trang web đó đã được tải về máy dưới dạng HTML, tốn một vùng RAM và hiển thị (render) trực tiếp lên trình duyệt thay vì được tải thành một tập tin rời.

		- Khi trang web được tải về RAM, nó được xem là một đối tượng bự nhất - cây DOM.
			+ Mỗi thành phần / thẻ xuất hiện trong cây DOM đều được xem là những đối tượng nhỏ hơn vì bên trong có thể chứa giá trị (id, name, color, type, margin, padding...), hành vi hoặc tiếp tục chứa những đối tượng khác.
			+ Mỗi thẻ sẽ được đại diện bằng một đối tượng của Interface trong Selenium được gọi là WebElement.

			Ví dụ: thẻ <div>, <h>, <span>,...
				-> Đều được xem là đối tượng vì có mô tả, đặc tính và hành vi.

		- Vì trang web đã được tải về trình duyệt, mà lại có một đối tượng nào đó đại diện cho trình duyệt (đối tượng được tạo từ lớp WebDriver), nghĩa là đối tượng này cũng đã nắm được toàn bộ đối tượng trong trang web (nắm được mã nguồn của trang web).

		(Lúc này, trình điều khiển trình duyệt sẽ bắt đầu phát huy công dụng khi dựa theo những lệnh trong code mà bắt đầu tương tác với trình duyệt thật.)

		* Java:
			// Khai báo thư viện lập trình Selenium WebDriver
			// tương ứng với ngôn ngữ lập trình đang sử dụng
			import org.openqa.selenium.WebDriver;
			import org.openqa.selenium.chrome.ChromeDriver;

			// Khi đưa WebDriver vào trong code
			// bằng cách tải thư viện lập trình,
			// lúc này, cả trình duyệt (nhờ WebDriver đại diện)
			// được xem là một đối tượng (object),
			// được tải về máy (hiển thị trực tiếp lên trình duyệt)
			// và chiếm bộ nhớ trong RAM,
			// ta có thể thoải mái gọi hàm
			// để điều khiển / yêu cầu trình duyệt
			// thực hiện các thao tác một cách tự động

			// WebDriver là một lớp trừu tượng - Interface
			// và ChromeDriver là một lớp kế thừa từ WebDriver

			// Tạo một đối tượng trình duyệt mới
			// và trỏ thẳng vào trình duyệt vật lý
			WebDriver trinhDuyetCuaToi = new ChromeDriver(tuyChonTrinhDuyet);

						     // Đây là một trình duyệt mới hoàn toàn
						     // và đại diện cho trình duyệt thật,
						     // nhưng sẽ không ảnh hưởng
						     // đến trình duyệt đang sử dụng
						     // và có thể được điều khiển
						     // thông qua đối tượng trinhDuyetCuaToi

			// Sử dụng đối tượng trinhDuyetCuaToi
			// để bắt đầu tương tác
			// và mở cửa sổ trình duyệt ở chế độ toàn màn hình,
			// thay thế cho cách truyền tham số vào hàm addArguments()
			trinhDuyetCuaToi.manage().window().maximize();

------------------------------------------------------------

	Bước 07: Tìm / định vị các phần tử trên website và xác định hành động, thông qua các API được viết sẵn trong Selenium WebDriver.

		- Vì đã là một đối tượng nên ta hoàn toàn có thể nhờ trình duyệt tìm giúp ta các thẻ nào đó.
		
		- Nhưng để đưa ra yêu cầu, trước hết ta phải biết thẻ đó (input, button, radio button, checkbox...) nằm ở đâu thông qua loại dữ liệu.
			+ Có rất nhiều kỹ thuật khác nhau để tìm ra vị trí của một thẻ, từ cách tiện lợi nhất là sử dụng định danh (id) cho đến những cách chuyên nghiệp như sử dụng CSS Selector và XPath.
			+ Sau khi đã biết được vị trí, ngoài việc lấy dữ liệu về, ta còn có thể đưa dữ liệu vào một ô textbox, nhấn các nút hoặc hyperlink, có thể bắt được chữ trên tag để so sánh giá trị và quyết định đúng sai...

		- Sau khi sử dụng đối tượng đại diện cho trình duyệt để tìm ra được phần tử dựa theo các kĩ thuật định vị, ta sẽ lưu trữ lại phần tử đó vào một đối tượng khác đại diện cho phần tử.

		* Java:
			import org.openqa.selenium.By;
			import org.openqa.selenium.WebElement;
			
			// Mở website lên
			trinhDuyetCuaToi.get("https://www.google.com/");

			// 	Lưu ý: Đường dẫn bắt buộc phải có thêm "https://"
			//	       để tránh bị ngoại lệ InvalidArgumentException
        
			// Sử dụng đối tượng đại diện cho trình duyệt
			// để tìm phần tử nằm trong trang web,
			// sau đó lưu phần tử vừa tìm được vào đối tượng
			// đại diện cho từng phần tử trong trang web
        		WebElement searchBox = trinhDuyetCuaToi.findElement(By.name("q"));

			// Sử dụng đối tượng đại diện cho phần tử
			// để bắt đầu tương tác với trang web
			searchBox.sendKeys("Kiểm thử phần mềm");
			searchBox.submit();

		* Python:
			trinh_dieu_khien_trinh_duyet.get('https://www.google.com/')
			trinh_dieu_khien_trinh_duyet.find_element(By.NAME, 'q')

------------------------------------------------------------

	Bược 08: Thực thi và kiểm tra kết quả. Selenium WebDriver sẽ gọi trực tiếp trình duyệt thông qua trình điều khiển do chính hãng phát hành trình duyệt đó cung cấp.

--------------------------------------------------------------------------------

* Lưu ý: Nếu tạo dự án Java bằng Maven, đôi khi sẽ vì lỗi [https://stackoverflow.com/a/75741758/7429447] mà khi thực thi mã nguồn, trình duyệt sẽ được mở nhưng trang web lại không thể nạp được; thường gặp trong trình duyệt Chrome ở phiên bản từ 111 trở lên và khi sử dụng bản Selenium quá cũ.

	| NetBeans: Failed to execute goal org.codehaus.mojo:exec-maven-plugin:1.5.0:exec (default-cli) on project ...

	| Eclipse: java.io.IOException: Invalid Status code=403 text=Forbidden

	* Cách khắc phục:

		1. Nếu sử dụng Selenium phiên bản dưới 4.5:

			// Trong mã nguồn
			ChromeOptions tuyChonTrinhDuyet  = new ChromeOptions();
			tuyChonTrinhDuyet.addArguments("--remote-allow-origins=*");
			WebDriver trinhDuyetCuaToi = new ChromeDriver(tuyChonTrinhDuyet);

		2. Nếu sử dụng Selenium phiên bản từ 4.5 trở lên:

			// Trong tập tin pom.xml
			<dependency>
				<groupId>org.seleniumhq.selenium</groupId>
				<artifactId>selenium-http-jdk-client</artifactId>
				<version>4.8.1</version>
			</dependency>

			// Trong mã nguồn
			System.setProperty("webdriver.http.factory", "jdk-http-client");

--------------------------------------------------------------------------------

	[CODE CƠ BẢN ĐỂ ĐIỀU KHIỂN TRÌNH DUYỆT BẰNG JAVA]

	String driverPath = "chromedriver.exe";
	System.setProperty("webdriver.chrome.driver", driverPath);

	ChromeOptions option = new ChromeOptions();
	option.addArguments("--remote-allow-origins=*");
	option.addArguments("--lang=en-GB");
	option.addArguments("--start-maximized");
	// myBrowser.manage().window().maximize();

	WebDriver myBrowser = new ChromeDriver(option);

	myBrowser.get("https://www.google.com/");
	WebElement searchBox = myBrowser.findElement(By.name("q"));
	searchBox.sendKeys("Kiểm thử phần mềm");
	searchBox.submit();

==========================================================================================

[NHỮNG LƯU Ý & MẸO TRONG QUÁ TRÌNH SỬ DỤNG SELENIUM WEBDRIVER]

--------------------------------------------------------------------------------

	[TUỲ CHỈNH CHO TRÌNH DUYỆT TRƯỚC KHI TƯƠNG TÁC]

Selenium WebDriver có cung cấp một lớp được gọi là ChromeOptions, cho phép người sử dụng có thể tuỳ chỉnh các thiết lập của trình duyệt Chrome.

* Cú pháp trong Java:

	import org.openqa.selenium.chrome.ChromeOptions;

	ChromeOptions option = new ChromeOptions();
	option.addArguments(...);
	option.addExtensions(...);

	WebDriver myBrowser = new ChromeDriver(option);

	Ví dụ: Mở rộng kích thước của cửa sổ trình duyệt.

		// Ngoài việc sử dụng đối tượng đại diện cho trình duyệt
		// để gọi hàm maximize(),
		// ta cũng có thể trực tiếp mở rộng kích thước của cửa sổ trình duyệt
		// thông qua việc cung cấp tham số cho tuỳ chọn
		option.addArguments("--start-maximized");

------------------------------------------------------------

		[NGÔN NGỮ MẶC ĐỊNH CHO TRÌNH DUYỆT]

Khi muốn chọn ngôn ngữ hiển thị mặc định cho trình duyệt, ta sẽ tuân theo tiêu chuẩn ISO 639-1:
	- Hai kí tự đầu tiên đại diện cho ngôn ngữ.
	- Hai kí tự tiếp theo đại diện cho quốc gia.

	Ví dụ: Cách chọn ngôn ngữ mặc định khi khởi động trình duyệt.

		option.addArguments("--lang=en-GB");
		// Ngôn ngữ: English (en)
		// Quốc gia: UNITED KINGDOM (GB)

		option.addArguments("--lang=vi-VN");
		// Ngôn ngữ: Vietnamese (vi)
		// Quốc gia: VIET NAM (VN)

* Tham khảo thêm:
	- Mã ngôn ngữ: https://www.w3schools.com/tags/ref_language_codes.asp
	- Mã quốc gia: https://www.w3schools.com/tags/ref_country_codes.asp
	- Danh sách kết hợp mã ngôn ngữ và quốc gia: http://www.lingoes.net/en/translator/langcode.htm

(Đây chỉ là ngôn ngữ hiển thị, việc định vị cho vị trí địa lý sẽ còn phụ thuộc vào những yếu tố khác.)

------------------------------------------------------------

		[CHẾ ĐỘ ẨN DANH CHO TRÌNH DUYỆT]

Khi sử dụng Selenium để mở trình duyệt ở chế độ ẩn danh:

	option.addArguments("--incognito");

Nhưng vì đây là một chế độ đặc biệt và WebDriver đã tối giản ở mức vừa đủ để sử dụng, nên một số tuỳ chọn và tình năng sẽ luôn ở trạng thái mặc định.
	- Tiện ích mở rộng đã cài đặt sẽ không xuất hiện ở chế độ này.
	- Một số trang sẽ yêu cầu xác nhận địa chỉ / vị trí để cung cấp thêm một số dịch vụ, nhưng vì không thể tự động theo dõi nên sẽ hiển thị cửa sổ thông báo để yêu cầu cung cấp thông tin.

* Lưu ý: Việc ẩn danh chỉ che giấu được hành vi ở phía người dùng, không thể giấu được nhà mạng và trang web.

------------------------------------------------------------

		[CÀI ĐẶT TIỆN ÍCH MỞ RỘNG CHO TRÌNH DUYỆT]

Sẽ có hai cách khác nhau để sử dụng tiện ích mở rộng khi tự động hoá trình duyệt.
	1. Sử dụng trực tiếp từ thư mục có sẵn trong máy tính (Chưa đóng gói - Unpacked).
	2. Sử dụng tập tin ở định dạng *.crx (Đã đóng gói - Packed).

----------------------------------------

* Cách 1: Chưa đóng gói - Unpacked (thư mục trên ổ đĩa):
	- Sau khi cài đặt tiện ích mở rộng vào trình duyệt, một thư mục tương ứng sẽ được tạo ra (và có đánh số hiệu phiên bản) ngay trên ổ đĩa của người dùng.
	- Vì vậy, để tận dụng thư mục này:
		+ Bắt buộc tiện ích mở rộng phải được cài đặt trên trình duyệt.
		+ Hoặc thư mục chứa tiện ích mở rộng đã được sao chép lại và lưu ở một nơi khác trước khi bị xoá trên trình duyệt.

	Bước 1: Bật "Chế độ dành cho nhà phát triển (Developer mode)" để lấy ID của tiện ích mở rộng, sau đó sao chép hoặc ghi nhớ lại ID.

	Bước 2: Chuyển sang trình quản lý tập tin (File Explorer) trên ổ đĩa và lần theo đường dẫn: "C:\Users\<tên-người-dùng>\AppData\Local\Google\Chrome\User Data\Default\Extensions".

	Bước 3: Tìm thư mục có tên trùng với ID của tiện ích mở rộng, mở thư mục lên (chứa số hiệu phiên bản của tiện ích mở rộng), sau đó sao chép đường dẫn của thư mục này.
		[* Lưu ý: Đôi khi, vì giới hạn quyền truy cập của người dùng trong hệ điều hành, ta cần sao chép thư mục này sang một phân vùng ổ đĩa khác.]

	Bước 4: Khai báo đường dẫn chứa thư mục của ích mở rộng trên ổ đĩa.

		// Thư mục chứa tiện ích mở rộng
		// đã được sao chép sang phân vùng ổ đĩa D
		// để tránh những rắc rối liên quan đến quyền truy cập
		option.addArguments("load-extension=D:\\1.50.0_1");

----------------------------------------

* Cách 2: Đã đóng gói - Packed (tập tin *.crx):
	- Ưu điểm của cách này là người dùng có thể sử dụng tập tin tiện ích mở rộng ở định dạng *.crx mà không cần phải cài đặt và giữ lại tiện ích mở rộng trong tình duyệt.
	- Tập tin *.crx sẽ tiện lợi hơn trong việc lưu trữ trên một máy chủ từ xa nào đó.

	Bước 1: Để có được tập tin *.crx, ta sẽ có những cách sau:

		* Cách 1: Sử dụng trang web sẵn có.
			| CRX Extractor: https://crxextractor.com/

			Bước 1.1: Sao chép đường dẫn đi đến trang cửa hàng Chrome trực tuyến (Chrome Web Store) của tiện ích mở rộng.
				Ví dụ: uBlock Origin - https://chrome.google.com/webstore/detail/ublock-origin/cjpalhdlnbpafiamejdnhcphjbkeiagm

				* Lưu ý: Nhớ loại bỏ thông tin ngôn ngữ trong URL (ví dụ: ?hl=en, ?hl=vi...).

			Bước 1.2: Nhấn nút [LET'S START] và dán địa chỉ vừa sao chép vào ô nhập địa chỉ.
			
			Bước 1.3: Nhấn nút [OK] để xác nhận đường dẫn và nhấn tiếp nút [GET .CRX] để tiến hành tải xuống tập tin *.crx.

				* Lưu ý: Trình duyệt sẽ xem tập tin được tải theo cách này là một mối nguy hại đối với máy tính, cứ tiếp tục tải xuống.

		* Cách 2.1: Tự đóng gói thủ công nếu đã từng cài đặt.

			Bước 2.1: Truy cập trang quản lý tiện ích mở rộng của trình duyệt.
				| chrome://extensions

			Bước 2.2: Bật "Chế độ dành cho nhà phát triển (Developer mode)" để lấy ID của tiện ích mở rộng, sau đó sao chép hoặc ghi nhớ lại ID.

			Bước 2.3: Chuyển sang trình quản lý tập tin (File Explorer) trên ổ đĩa và lần theo đường dẫn: "C:\Users\<tên-người-dùng>\AppData\Local\Google\Chrome\User Data\Default\Extensions".

			Bước 2.4: Tìm thư mục có tên trùng với ID của tiện ích mở rộng, mở thư mục lên (chứa số hiệu phiên bản của tiện ích mở rộng), sau đó sao chép đường dẫn của thư mục này.
				* Lưu ý: Đôi khi, vì giới hạn quyền truy cập của người dùng trong hệ điều hành, ta cần sao chép thư mục này sang một phân vùng ổ đĩa khác.

			Bước 2.5: Quay trở lại trang quản lý tiện ích mở rộng của trình duyệt, nhấn vào nút "Đóng gói tiện ích (Pack extension)".

			Bước 2.6: Dán đường dẫn thư mục trên ổ đĩa của máy tính (chứa số hiệu phiên bản của tiện ích mở rộng) vào ô "Thư mục gốc của tiện ích (Extension root directory)".
			
			Bước 2.7: Nhấn nút "Đóng gói tiện ích (Pack extension)" và nhấn tiếp nút [OK] trên hộp thoại thông báo.
				[Tập tin *.crx và *.pem được tạo ra sẽ nằm chung phân cấp với thư mục chứa tiện ích mở rộng lúc chưa đóng gói.]

		* Cách 2.2: [Đã lỗi thời và không hoạt động] Đóng gói bằng cửa sổ dòng lệnh cmd.

			Gọi chrome.exe (C:\Program Files\Google\Chrome\Application) bằng dòng lênh:
				--pack-extension: Thư mục chứa tiện ích mở rộng.
				--pack-extension-key: Thư mục chứa tiện ích mở rộng sau khi đã đóng gói.

				"chrome.exe --pack-extension=V:\1.50.0_1 --pack-extension-key=S:\1.50.0_1.pem"

		* Cách 3: Sử dụng thêm một tiện ích mở rộng khác.
			| CRX Extractor/Downloader: https://chrome.google.com/webstore/detail/crx-extractordownloader/ajkhmmldknmfjnmeedkbkkojgobmljda
				* Lưu ý: Nếu có bật tính năng "Duyệt web an toàn có tăng cường bảo vệ (Enhanced Safe Browsing)", trình duyệt sẽ hiển thị thêm một hộp thoại để xác nhận cài đặt.

			| Get CRX: https://chrome.google.com/webstore/detail/get-crx/dijpllakibenlejkbajahncialkbdkjc


			Bước 3.1: Sau khi cài đặt tiện ích mở rộng, đi đến trang cửa hàng Chrome trực tuyến (Chrome Web Store) của tiện ích mở rộng.
				Ví dụ: uBlock Origin - https://chrome.google.com/webstore/detail/ublock-origin/cjpalhdlnbpafiamejdnhcphjbkeiagm

			Bước 3.2: Nhấn chuột phải vào một khoảng trống bất kì trên trang của tiện ích mở rộng cần lấy tập tin *.crx, các tuỳ chọn để tải sẽ xuất hiện.

	Bước 2: Di chuyển tập tin *.crx đến đường dẫn tuỳ chọn.

	Bước 3: Khai báo đường dẫn chứa tập tin tiện ích mở rộng trên ổ đĩa.

		import java.io.File;

		// Đường dẫn nằm chung trong thư mục của dự án,
		// giống với tập tin chromedriver.exe
		option.addExtensions(new File("extension_1_50_0_0.crx"));

--------------------------------------------------------------------------------

	[PHÂN BIỆT GIỮA SUBMIT() VÀ CLICK()]

Khi lập trình sự kiện nhấn một nút trên trình duyệt:
	- Sử dụng hàm Submit() khi nút bấm đó là nút bấm thật sự nằm trong form.
	- Sử dụng hàm Click() khi nút bấm đó chỉ là label được chèn hyperlink.

--------------------------------------------------------------------------------

	[PHÂN BIỆT PHƯƠNG THỨC CLOSE() VÀ QUIT()]

close(): đóng duy nhất một trình duyệt đang sử dụng. Nếu có nhiều hơn một trình duyệt đang được mở bởi Selenium, thì câu lệnh này sẽ chỉ đóng trình duyệt mà ta đang trực tiếp thao tác, những trình duyệt còn lại đang được mở sẽ không bị ảnh hưởng.

quit(): đóng toàn bộ những trình duyệt đang sử dụng. Nếu có nhiều hơn một trình duyệt đang được mở bởi Selenium, thì câu lệnh này sẽ tắt toàn bộ WebDriver hiện thời (ngắt đối tượng WebDriver) và đóng hết toàn bộ trình duyệt đang được mở.

	-> Sự khác biệt chỉ đến khi Selenium đang mở từ hai trình duyệt trở lên.

--------------------------------------------------------------------------------

	[CƠ CHẾ CHỜ ĐỢI / ĐỒNG BỘ - WAIT]

Trong quá trình thao tác (thường là chuyển trang), do câu lệnh điều khiển (chạy trên máy ảo) và trang web (chạy trên trình duyệt) là hai luồng (thread) riêng biệt và không đồng bộ (async).

	- Trong một số trang web, để tăng tốc độ tải khi có nhiều hình ảnh, có thể trang sẽ không hiển thị ra hết toàn bộ nội dung (các thẻ, hình ảnh...) trong một lần mà sẽ tải về theo từng phần.

	- Đôi khi, cũng vì những lý do khách quan (ví dụ: kết nối mạng không ổn định...) hoặc những lý do chủ quan (ví dụ: bản thân trang web không được tối ưu...) khiến việc tải được hết toàn bộ nội dung của trang web sẽ tốn một khoảng thời gian nhất định.

	- Việc trình duyệt tải trang về máy tính và câu lệnh Selenium để điều khiển sẽ có sự chênh lệch với nhau giữa tốc độ.
		+ Code chỉ có thể ra lệnh chứ không thể can thiệp vào và điều khiển tốc độ tải của trang, vì đây đã là công việc của trình duyệt.
		+ Nên đôi khi sẽ có hiện tượng những câu lệnh của được thực thi nhanh hơn mức cần thiết so với tốc độ nạp của trang web, dẫn đến sự không đồng bộ và không tìm thấy phần tử để tương tác (no such element).

	- Để khắc phục tình trạng này, cần sử dụng thêm câu lệnh wait để câu lệnh đợi trang web.

	-> Sử dụng wait để đồng bộ tốc độ khi code thực thi nhanh hơn việc trang được nạp.
		(Câu lệnh chạy nhanh, nhưng trang web lại có độ trễ trong việc tải nội dung.)

------------------------------------------------------------

Có hai loại wait:

	- Tường minh (Explicit): Khá đơn giản nếu đã có kinh nghiệm trong việc đợi và tính toán, dự trù được khoảng thời gian gần chính xác để tải được toàn bộ trang web.
		- Sử dụng thông qua lớp Thread.
		- Lúc này, ta sẽ yêu cầu các câu lệnh chủ động "đứng hình mất vài giây" trước khi tiếp tục quay lại xử lý.
		-> Ước lượng trước khoảng thời gian cần chờ.

	- Ngầm định (Implicit): Khó viết nhưng sẽ an toàn hơn.
		- Do Selenium cung cấp sẵn và sử dụng thông qua đối tượng đại diện cho trình duyệt, thông báo rằng không nên vội mà hãy đợi đến khi trang web được tải xong (giống như việc xem tín hiệu trong bảng điều khiển Network của trình duyệt) thì mới bắt đầu tìm kiếm phần tử.
		- Tuy không nói rõ sẽ phải chờ trong bao lâu, chỉ biết khi nào trang web được tải xong thì các câu lệnh mới được tiếp tục thực thi.
		-> Chờ đợi đến khi nhìn thấy dấu hiệu.

--------------------------------------------------------------------------------

	[XỬ LÝ NGOẠI LỆ]

Thay vì phải trực tiếp xử lý ngoại lệ, ta có thể "uỷ quyền" cho một nơi khác để xử lý giùm.

	Ví dụ: xử lý ngoại lệ khi có sử dụng hàm sleep()

		// 01. Ném ra bên ngoài thông báo rằng có thể xảy ra ngoại lệ,
		//     nơi nào sử dụng / gọi hàm thì phải xử lý ngoại lệ
		public static void testGoogleWithInIncognitoMode() throws InterruptedException {

			...

			// Đây là hàm thao tác với hệ điều hành
			// để ép ứng dụng phải "đứng hình mất 3 giây",
			// nên có thể phát sinh vấn đề
			// liên quan đến bộ lập trình (scheduler)
			// và phát sinh ngoại lệ,
			// vì vậy, phải bắt ngoại lệ
			Thread.sleep(3000);

			// Nhưng thay vì tự mình xử lý ngoại lệ,
			// thì lại để cho nơi gọi hàm tự xử lý ngoại lệ
		}

		// 02. Nơi nào gọi main() thì cũng phải tự xử lý ngoại lệ,
		//     mà người gọi main() ở đây lại chính là hệ điều hành,
		//     nên nếu có xảy ra thì hệ điều hành sẽ tự xử lý
		//     bằng cách kết thúc tiến trình (end task)
		public static void main(String[] args) throws InterruptedException {
			testGoogleWithInIncognitoMode();
		}

--------------------------------------------------------------------------------

	[XỬ LÝ CHUỖI]

Cắt bớt chuỗi thừa bằng Java:

	Ví dụ: Trong trang web https://www.thegioididong.com/, một số sản phẩm sẽ có thêm dấu '*' nằm ngay phía sau giá bán.

		// Bị thừa kí tự '*' trong giá bán
		String price = "290₫ *";

		// Lấy và in ra được vị trí của kí tự '*'
		// (trả về kết quả -1 nếu không tìm thấy kí tự)
		int index = price.indexOf('*');
		System.out.println("index: " + index);

		// Kiểm tra kết quả trả về,
		// nếu tìm thấy thì xoá kí tự thừa đi
		String afterPrice = price;
		if (index >= 0)
			afterPrice = price.substring(0, price.length() - 2);
							// Vì độ dài length() tính từ 1
							// còn chỉ số (index) tính từ 0,
							// nên (price.length() - 2)
							// hoặc (index - 1)

		// In ra giá bán cuối cùng
		System.out.println("Final price (after removing *): "
					+ afterPrice);

--------------------------------------------------------------------------------

	[MỘT SỐ HÀM LIÊN QUAN ĐẾN ĐỐI TƯỢNG WEBELEMENT]

getText(): Lấy nội dung bên trong một thẻ.

--------------------------------------------------------------------------------

	[XỬ LÝ CỬA SỔ THÔNG BÁO NỔI - ALERTS & POPUPS]

Trong quá trình tương tác với trình duyệt bằng Selenium sẽ có hai dạng cửa sổ thông báo nổi.

	1. Của riêng ứng dụng: tương tác trong trang đã được trình duyệt tải về.
		-> Tương tác giống như những thẻ bình thường khác.

		Ví dụ: Trên trang https://www.thegioididong.com/

			WebElement locationPopup = myBrowser.
				findElement(By.xpath("//*[@id='lc_pop--sugg']/div/div[2]/a[2]"));
			locationPopup.click();

	2. Của riêng trình duyệt:
		-> Tương tác trực tiếp bằng đối tượng đại diện cho trình duyệt.

		Ví dụ: Tắt hộp thoại thông báo (alert) trên trình duyệt.

			myBrowser.switchTo().alert().accept();

--------------------------------------------------------------------------------

	[TỰ ĐỘNG CẬP NHẬT PHIÊN BẢN CHO TRÌNH ĐIỀU KHIỂN TRÌNH DUYỆT
	 BẰNG WEBDRIVERMANAGER]

Khi muốn sử dụng Selenium, điều quan trọng nhất để đảm bảo code luôn chạy đúng là: phiên bản của trình duyệt phải trùng với phiên bản của trình điều khiển trình duyệt (Browser WebDriver) do chính hãng phát triển nên trình duyệt đó cung cấp.
	-> Luôn phải kiểm tra phiên bản của trình duyệt và trình điều khiển trình duyệt một cách thủ công.

Vì triết lý thiết kế "evergreen" mà những phiên bản mới nhất sẽ luôn luôn được tự động cập nhật.
	- Để tránh mất thời gian cho những công đoạn: kiểm tra phiên bản, tải WebDriver, khai báo đường dẫn, thông báo cho máy ảo, duy trì sự đồng bộ giữa các phiên bản...
	- Một lớp riêng tên là "WebDriverManager", đóng gói dưới dạng tập tin *.jar, được tạo ra để tự động hoá các thao tác tốn thời gian kể trên thành một câu lệnh đơn giản.
	-> Đóng gói các thao tác tốn thời gian thành thư viện WebDriverManager.

------------------------------------------------------------

WebDriverManager là một thư viện nguồn mở của Java do Boni García phát triển và chuyện được sử dụng để tự động hoá quá trình quản lý trình điều khiển trình duyệt.

Quá trình tự động hoá quản lý trình điều khiển trình duyệt sẽ bao gồm các tác vụ:
	- Download: Tải phiên bản phù hợp với trình duyệt.
	- Setup: Cấu hình biến môi trường.
	- Maintenance: Đảo bảo rằng phiên bản của trình duyệt và trình điều khiển trình duyệt luôn luôn khớp nhau.

Bắt đầu từ phiên bản 5, WebDriverManager còn hỗ trợ thêm nhiều tính năng nâng cao khác.
	(* Tham khảo thêm: https://bonigarcia.dev/webdrivermanager/)

* Các bước để sử dụng WebDriverManager trong dự án Maven của Java:

	Bước 01: Khai báo thư viện phụ thuộc (Dependency) theo phong cách Maven. Khai báo trong phạm vị (scope) là các lớp để test.
		| https://mvnrepository.com/artifact/io.github.bonigarcia/webdrivermanager

	Bước 02: Trong hàm main(), khai báo biến để đại diện cho trình duyệt và thuộc thư viện WebDriver của Selennium.
		| WebDriver trinhDuyetCuaToi;

	Bước 03.01: [Tuỳ chọn] Nếu không tìm thấy thư viện WebDriver của Selenium (không được import một cách tự động).
		- Đi tìm thư viện phụ thuộc (Dependency) cho WebDriver đã khai báo ở trên bằng cách chọn "Search Dependency at Maven Repositories for WebDriver".
		- Lúc này, IDE sẽ đi vào thư mục .m2 dưới máy cục bộ để đi tìm, sau đó người dùng sẽ chọn phiên bản Selenium cần sử dụng.

		(Trong quá trình đi tìm thư viện, nếu không tìm thấy dù đã tải thư viện về kho chứa cục bộ, thì có thể nhấn nút [Clean and Build Project] trên NetBeans.)

	Bước 03.02: [Tuỳ chọn] Tự nhớ câu khai báo thư viện WebDriver của Selennium và import một cách thủ công.
		| import org.openqa.selenium.WebDriver;

	Bước 04: Để sử dụng được tính năng tự động hoá quản lý trình điều khiển trình duyệt, ta sẽ chỉ định một trình điều khiển đến từ một nhà phát triển trình duyệt và sau đó gọi phương thức setup().
		| WebDriverManager.chromedriver().setup();

		* Nếu cũng không tìm thấy thư viện WebDriverManager:
			- Tìm kiếm trong kho cục bộ hoặc nhấn nút [Clean and Build Project] trên NetBeans giống như bước 03.01.
			- Thêm một cách thủ công giống như bước 03.02.
				| import io.github.bonigarcia.wdm.WebDriverManager;

	Bước 05: Tạo đối tượng đại diện cho trình duyệt và trỏ thẳng vào trình duyệt vật lý, nhưng vẫn độc lập với trình duyệt vật lý.
		| trinhDuyetCuaToi = new ChromeDriver();

		* Nếu cũng không tìm thấy thư viện ChromeDriver:
			- Tìm kiếm trong kho cục bộ hoặc nhấn nút [Clean and Build Project] trên NetBeans giống như bước 03.01.
			- Thêm một cách thủ công giống như bước 03.02.	
				| import org.openqa.selenium.chrome.ChromeDriver;

		* Có thể bỏ qua bước tạo đối tượng đại diện cho trình duyệt bằng cách sử dụng trực tiếp hàm create() thay cho hàm setup():
			| trinhDuyetCuaToi = WebDriverManager.chromedriver().create();

				// Hai câu lệnh:
				//	WebDriverManager.chromedriver().setup();
				//	myBrowser = new ChromeDriver();
				//
				// Được thay thế bằng một câu duy nhất:
				//	myBrowser = WebDriverManager.chromedriver().create();

	Ví dụ: Một Test Case sử dụng JUnit 5 và phương thức AssertJ (https://joel-costigliola.github.io/assertj/).

		import static org.assertj.core.api.Assertions.assertThat;

		import org.junit.jupiter.api.AfterEach;
		import org.junit.jupiter.api.BeforeAll;
		import org.junit.jupiter.api.BeforeEach;
		import org.junit.jupiter.api.Test;
		import org.openqa.selenium.WebDriver;
		import org.openqa.selenium.chrome.ChromeDriver;

		import io.github.bonigarcia.wdm.WebDriverManager;

		class ChromeTest {

			WebDriver driver;

			@BeforeAll
			static void setupClass() {
				WebDriverManager.chromedriver().setup();

				// WebDriverManager.firefoxdriver().setup();
				// WebDriverManager.edgedriver().setup();
				// WebDriverManager.operadriver().setup();
				// WebDriverManager.chromiumdriver().setup()
				// WebDriverManager.iedriver().setup();

				// driver = WebDriverManager.chromedriver().create();
			}

			@BeforeEach
			void setupTest() {
				driver = new ChromeDriver();

				// Có thể bỏ qua bước
				// tạo mới đối tượng driver trong @BeforeEach
				// bằng cách sử dụng hàm create()
				// thay thế cho setup() trong @BeforeAll

				// driver = WebDriverManager.chromedriver().create();
			}

			@AfterEach
			void teardown() {
				driver.quit();
			}

			@Test
			void test() {
				// Exercise
				driver.get("https://bonigarcia.dev/selenium-webdriver-java/");
				String title = driver.getTitle();

				// Verify
				assertThat(title).contains("Selenium WebDriver");
			}

		}

==========================================================================================
==========================================================================================
==========================================================================================

[KỸ THUẬT ĐỊNH VỊ CÁC THẺ TRONG TRANG WEB - BỘ ĐỊNH VỊ LOCATOR]

	* Crawler (Spider / Spiderbot): kỹ thuật sử dụng Selenium và Locator để tự động truy cập vào các trang web và lấy dữ liệu.

--------------------------------------------------------------------------------

	[ĐỊNH NGHĨA]

Khi HTML và CSS kết hợp với nhau sẽ tạo thành một trang web tĩnh, Locator được xem là địa chỉ của từ khoá.

Bên cạnh việc định nghĩa ra cách thiết kế trình duyệt (phải có cách để lập trình viên can thiệp vào)L, W3C còn định nghĩa thêm và chuẩn hoá cho những thứ có liên quan đến HTML.

	- Khi W3C chuẩn hoá HTML, họ đã đưa ra những cách (kỹ thuật, cơ chế) để định vị được các thẻ (tag) / phần tử (web element) trong website, kỹ thuật để nói về một thẻ tại một vị trí nào đó trong hàng nghìn thẻ khác của một trang HTML khi nó đã được tải về máy tính.

	- Một khi đã định vị chính xác được phần tử cần tìm, thì sẽ lấy được các sự kiện (event) và gửi yêu cầu đến để phần tử làm một công việc nào đó. Vì vậy, việc xác định được chính xác phần tử đóng vai trò rất quan trọng trong việc thành công của một Test Script.

	-> Kỹ thuật tìm một thẻ bất kì trong trang web.

* Bộ định vị (Locator): Là kỹ thuật mò vào trong trang web đã được Server trả về máy tính (trong DOM) để định vị chính xác một phần tử cụ thể giữa vô vàn phần tử khác, sau đó tương tác với phần tử này.
	(Giống như một câu truy vấn để lấy dữ liệu trong các hệ quản trị cơ sở dữ liệu.)

--------------------------------------------------------------------------------

	[TÌM PHẦN TỬ TRÊN TRÌNH DUYỆT BẰNG CÔNG CỤ DÀNH CHO NHÀ PHÁT TRIỂN]

* Có hai kiểu tìm phần tử:

----------------------------------------

	1. Tuyệt đối (Absolute - Abs / Full): Đi qua tất cả các điểm, không được bỏ qua bất kì điểm nào vì sẽ không tìm thấy đường đi.
		- Đưa đầy đủ thông tin và tốc độ chạy nhanh hơn, nhưng Test Script sẽ dễ bị sai khi có thay đổi trong XPath.
		- Chỉ sử dụng khi hết cách.
		-> Xuất phát từ gốc của cây phân cấp và đi đến đích.

		Ví dụ: Đường dẫn tuyệt đối theo phong cách của XPath.
		
			/html/body/section[1]/h1

----------------------------------------

	2. Tương đối (Relative - Rel): Không nói rõ đường đi và có thể nhảy cóc qua bất kì điểm nào.
		- Đưa rất ít thông tin và tốc độ chạy chậm hơn vì phạm vi quét rộng hơn, nhưng sẽ chấp việc thay đổi trong XPath.
		- Nên ưu tiên sử dụng trong hầu hết các trường hợp.
		-> Xuất phát tại một điểm bất kì trên cây phân cấp và sau đó đi tiếp.

		Ví dụ: Đường dẫn tương đối theo phong cách của CSS Selector.
			
			section[class='detail '] h1

------------------------------------------------------------

* Cách định vị các phần tử ngay trên trình duyệt (Windows):

----------------------------------------

	Bước 01: Mở Công cụ dành cho Nhà phát triển (Web Developer Tools / Browser Developer Tools).

		* Sử dụng phím tắt (Shortcut):

			- Chrome:
				1. Sử dụng phím tắt [F12]
					-> Mở bảng điều khiển Elements

				2. Sử dụng tổ hợp phím [Ctrl] + [Shift] + [I]
					-> Mở bảng điều khiển Elements

				2. Sử dụng tổ hợp phím [Ctrl] + [Shift] + [J]
					-> Mở bảng điều khiển Console

			- Firefox:
				1. Sử dụng phím tắt [F12]
					-> Mở bảng điều khiển Inspector

				2. Sử dụng tổ hợp phím [Ctrl] + [Shift] + [I]
					-> Mở bảng điều khiển Inspector

		* Sử dụng menu ngữ cảnh (Context Menu):

			- Chrome: Chuột phải > Inspect

			- Firefox: Chuột phải > Inspect (Q)

		* Sử dụng biểu tượng [⋮] hoặc [≡]:

			- Chrome: More tools > Developer tools

			- Firefox: More tools > Web Developer Tools

----------------------------------------

	Bước 02: Chọn / định vị phần tử cần tương tác để xem các thông tin về thuộc tính.

		* Sử dụng phím tắt (Shortcut):

			- Chrome: [Ctrl] + [Shift] + [C]

			- Firefox: [Ctrl] + [Shift] + [C]

		* Sử dụng biểu tượng:

			- Chrome: [Select an element in the page to inspect it] > Rê chuột đến phần tử cần định vị

			- Firefox: [Pick an element from the page] > Rê chuột đến phần tử cần định vị

----------------------------------------

	Bước 03: Sao chép định vị của phần tử.

		* Tận dụng Công cụ dành cho Nhà phát triển (Web Developer Tools / Browser Developer Tools):

			- Chrome: Chuột phải > Copy > Chọn loại locator muốn sử dụng

			- Firefox: Chuột phải > Copy > Chọn loại locator muốn sử dụng

		* Sử dụng tiện ích mở rộng:

			- SelectorsHub.

			- ChroPath.

		* Sử dụng các kỹ thuật / chiến lực định vị phần từ trên trang web, phổ biến nhất là XPath và CSS Selector.

----------------------------------------

	Bước 04: Kiểm tra lại xem liệu định vị vừa sao chép có phải là duy nhất.

		* Sử dụng khung tìm kiếm được tính hợp bằng phím tắt để viết câu truy vấn:

			- Chrome: trong bảng điều khiển Elements > [Ctrl] + [F]

			- Firefox: trong bảng điều khiển Inspector > [Ctrl] + [F]

==========================================================================================

[CÁC CHIẾN LƯỢC ĐỊNH VỊ PHẦN TỬ TRÊN WEB - LOCATOR STRATEGIES]

	* Các chỉ số của phần tử sẽ bắt đầu từ 1 thay vì 0 giống như mảng trong lập trình. *

Có rất nhiều cách khác nhau để xác định chính xác và duy nhất một phần tử (element) trong trang web.

Selenium cung cấp lớp "By", bên trong gồm nhiều phương thức (ví dụ: className(), cssSelector(), id(), linkText(), name(), partialLinkText(), taName(), xpath()...) để hỗ trợ tìm các phần tử trong DOM.

--------------------------------------------------------------------------------

	[ĐỊNH VỊ TRUYỀN THỐNG - TRADITIONAL LOCATOR]

Có 8 chiến lược / kỹ thuật định vị truyền thống trong WebDriver:

	1. Class name: Sử dụng thuộc tính class để tìm đối tượng.
		- Thường có thể tìm ra được một loạt các thẻ có cùng tên class, vì thẻ này là để áp dụng hàng loạt.
		- Không cho phép có nhiều tên class - compound class name (ví dụ: nếu tên class đặt có khoảng trắng, thì sẽ được tính là hai tên class.).

	2. CSS Selector: Tận dụng cú pháp của CSS trong việc chọn phần tử.

	3. Id: Theo quy định thiết kế của W3C, id không nên trùng nhau (nhưng chưa cấm hẳn).
		- Vì vậy, sử dụng thuộc tính id để tìm chính xác phần tử.
		- Đây là cách tiện lợi và nhanh gọn nhất.

	4. Name: Sử dụng thuộc tính name.

	5. Link Text: Sử dụng đoạn văn bản được hiển thị trong siêu liên kết (hyperlink).

	6. Partial Link Text: Sử dụng một phần của đoạn văn bản được hiển thị trong siêu liên kết (hyperlink). Nếu có nhiều kết quả được tìm thấy, thì kết quả đầu tiên sẽ được chọn.

	7. Tag Name: Sử dụng tên của thẻ / bộ thẻ.

	8. XPath: Sử dụng biểu thức XPath - ngôn ngữ được sử dụng để truy vấn trong XML.

(* Tham khảo thêm:
	- https://www.toolsqa.com/selenium-webdriver/selenium-locators/
	- https://www.selenium.dev/documentation/webdriver/elements/locators/)

(* Mẹo: https://vananhtooo.wordpress.com/2018/08/10/mot-vai-trick-khi-su-dung-xpath-va-css-selector-trong-selenium/)

--------------------------------------------------------------------------------

	[ĐỊNH VỊ TƯƠNG ĐỐI - RELATIVE LOCATOR / FRIENDLY LOCATOR]

Được giới thiệu từ Selenium 4.

==========================================================================================

[XPATH VÀ CSS SELECTOR]

--------------------------------------------------------------------------------

[XPATH]

* XPath: Lần mò theo cây DOM để tìm duyệt/định vị thẻ một cách tương đối trong website.

Dựa trên ngôn ngữ XML (bố của HTML), mô tả theo cặp thẻ và đánh dấu ý nghĩa của từng cặp thẻ (Markup Language).

	Ví dụ:
		<div> - Division: Phân vùng
		<span> - Span: Gom nhóm
		<b> - Bold: In đậm
		<i> - Italic: In nghiêng
		<u> - Underline: Gạch chân/Gạch dưới
		...

------------------------------------------------------------

	[CÁC CẤU TRÚC / LOẠI ĐƯỜNG DẪN XPATH]

* XPath tuyệt đối: 

	Ví dụ: Cấu trúc XPath tương đối của ô đăng nhập - địa chỉ email.

		/html/body/div/div/div[2]/div/div/div/form/div/div[2]/div[1]/ul/li[1]/div/input
		(Website: http://live.techpanda.org/index.php/customer/account/login/)

* XPath tương đối: //tag-name[@attribute-name='attribute-value']

	Ví dụ: Cấu trúc XPath đơn giản của một số phần tử.
	
		//input[@id='txtPhoneNumber']
		(Website: https://www.thegioididong.com/lich-su-mua-hang/dang-nhap)
	
		//input[@name='login[username]']
		//input[@id='email'] hoặc //*[@id='email']
		(Website: http://live.techpanda.org/index.php/customer/account/login/)

----------------------------------------

Sự khác nhau giữa "//" và '/'.

* Một dấu gạch chéo (dấu xiên, dấu xuyệt trái) '/':
	- Chỉ định thẻ con trực tiếp.
	- Thường sử dụng trong các đường dẫn tuyệt đối.

* Hai dấu gạch chéo (dấu xiên, dấu xuyệt trái) "//":
	- Chỉ định toàn bộ thẻ con.
	- Thường sử dụng trong các đường dẫn tương đối.

----------------------------------------

Để việc tìm phần tử được chính xác hơn:

	1. Nếu có từ hai node con giống nhau hoàn toàn trở lên thì ta sẽ xét đến node cha (parent node) của nó, sau đó viết XPath hai lần, một lần cho node cha và một lần cho node con cần tìm.

		Ví dụ: Có nhiều hơn một kết quả trả về khi sử dụng XPath.

			Nếu tìm kiếm theo "//a[@title='My Account']" sẽ cho ra hai kết quả trong cùng một trang.
				-> Sử dụng đến node cha.

			Trong đó: //div[@class='footer'] <- node cha
			Trong đó: //a[@title='My Account'] <- node con
			(Website: http://live.techpanda.org/index.php/customer/account/login/)

			Kết quả: //div[@class='footer']//a[@title='My Account']
			
			Được hiểu: Lấy phần tử với đường link là "My Account"
				   ở phần footer của website

----------------------------------------

	[MẸO ĐỂ GIÚP CODE DỄ ĐỌC HƠN]

1. Ưu tiên sử dụng dấu nháy đơn 'attribute-value' hơn là dấu nháy kép "attribute-value" vì ở một số IDE (ví dụ: Eclipse...), sẽ tự động thêm một số kí tự để không bị hiểu nhầm rằng cặp dấu nháy đôi "" vừa được thêm vào là dấu kết thúc chuỗi.

	Ví dụ: Nếu sử dụng cặp dấu nháy kép.

		// Kí hiệu "\" sẽ tự động được IDE thêm vào

		//input[@id=\"txtEmail\"]
		(Website: https://alada.vn/tai-khoan/dang-ky.html)

2. Dấu sao/hoa thị '*' (thường thấy khi sao chép XPath từ trình duyệt thay vì gõ thủ công) đại diện cho bất kì thẻ (tag) nào.
	- Nếu sử dụng sẽ khiến việc quét bị lâu so với khi truyền tên thẻ trực tiếp do phải đi kiểm tra/so sánh với tất cả các thẻ.
	- Bên cạnh đó, việc sử dụng dấu hoa thị '*' cũng dễ gây hiểu lầm khi đọc code do không biết đó là loại phần tử gì.

	Ví dụ: Cách sử dụng dễ gây hiểu lầm và tốn thời gian tìm kiếm.

		//*[@id="txtEmail"]
		(Website: https://alada.vn/tai-khoan/dang-ky.html)

------------------------------------------------------------

	[CÁC HÀM TRONG XPATH]

* Lấy tuyệt đối:

	text()=''

		Ví dụ: //strong[text()='Khách hàng mới']
			(Website: https://www.nopcommerce.com/vi/login)

	string()=''

	@attribute=''

* Lấy tương đối:

	contains(.,'') = contains(string(),'')

		Ví dụ: //div[contains(text(),'có thể đăng câu hỏi')]
			(Website: https://www.nopcommerce.com/vi/login)

		starts-with(text(),''): Lấy chuỗi, giá trị của thuộc tính bắt đầu bằng giá trị nào (nhưng không có ends-with).

Dấu chấm . giúp tìm phần tử ở bất kì đâu miễn là vẫn trong thẻ đó.

--------------------------------------------------------------------------------

[CSS SELECTOR]

* CSS Selector: dấu chấm đại diện cho class, dấu thăng đại diện cho các thuộc tính bên trong.

	- Dấu khoảng trắng đại diện cho thẻ con.

Cấu trúc (tương đối): tag-name[attribute-name='attribute-value']

	Ví dụ: input[name="login[username]"]
		(Website: http://live.techpanda.org/index.php/customer/account/login/)

==========================================================================================

[KỸ THUẬT TƯƠNG QUAN - AXES / AXIS]

Nếu trong các trang web có sử dụng thêm những framework phức tạp, cấu trúc sẽ tự động được tạo, khiến những giá trị trong các thuộc tính liên tục bị thay đổi sau mỗi lần F5.
	-> Định vị bị thay đổi sau mỗi lần chạy.

Sử dụng kỹ thuật định vị tương đối để tìm những phần tử khi chúng có dính líu, liên hệ với nhau (có tương quan), mà không cần quan tâm đến tên thẻ hay thuộc tính của thẻ.
	-> Định vị dựa trên sự tương đối giữa các thẻ.

==========================================================================================
==========================================================================================
==========================================================================================

==========================================================================================

==========================================================================================

==========================================================================================

* Tự học thêm:
	- https://www.techlistic.com/p/selenium-tutorials.html

==========================================================================================

--------------------------------------------------------------------------------

------------------------------------------------------------

----------------------------------------

--------------------

----------






























