[PHÂN LOẠI KIỂM THỬ - TYPE / CATEGORY / CLASSIFY]

Cùng một đối tượng, ta có thể nhìn ở rất nhiều góc nhìn khác nhau.
	Ví dụ: đối tượng sinh viên
		- Lứa tuổi: tuổi thanh xuân.
		- Trình độ học vấn: trình độ cao (cao đẳng, đại học).
		- Giới tính: nam/nữ/giới tính thứ ba.
		- Học tập: chuyên ngành Kỹ thuật phần mềm,...
		- Hoạt động xã hội: có tham gia và không tham gia.

Kiểm thử phần mềm cũng tương tự, ta có thể chia những vấn đề liên quan đến kiểm thử thành những nhóm khác nhau.

Việc phân loại kiểm thử chưa bao giờ dễ dàng khi có đến hơn 100 loại kiểm thử khác nhau, vì vậy không đáng để quan tâm rằng kỹ thuật kiểm thử này thuộc nhóm kiểm thử nào, chỉ cần quan tâm đến nhu cầu và mục tiêu cuối cùng là kiểm thử: kiểm thử thứ gì, chức năng gì...
	-> Mục tiêu cuối cùng là để so sánh kết quả mong đợi với kết quả thực tế.

	Ví dụ:
		* Nhu cầu:
			- Viết Unit Test bằng thư viện JUnit
			- Tách dữ liệu kiểm thử ra một nơi riêng

		* Mục tiêu: nhận kết quả kiểm thử một cách tự động

			=> Kiểm thử hướng dữ liệu (Data-driven testing)

--------------------------------------------------------------------------------

 ---------------------------------------------------------------------------------------
| You can do Functional Testing (A Type)| Muốn kiểm thử một LOẠI nào đó			|
| during System Testing (A Level)	| diễn ra trong GIAI ĐOẠN nào đó		|
| using Black Box Testing (A Method)	| bằng KỸ THUẬT / PHƯƠNG PHÁP cụ thể nào đó	|
 ---------------------------------------------------------------------------------------

	Ví dụ:
		kiểm thử CHỨC NĂNG [Đăng nhập]
		trong GIAI ĐOẠN hệ thống đã gần hoàn chỉnh
		bằng KỸ THUẬT kiểm thử hộp đen.

==========================================================================================
==========================================================================================
==========================================================================================

[01. PHÂN LOẠI THEO MỨC ĐỘ / CẤP ĐỘ - TESTING LEVEL]

** Mức độ / Cấp độ kiểm thử (Testing Level): bàn về các công việc kiểm thử được thực hiện dựa vào sự hoàn thiện của hệ thống trong quá trình viết code, mỗi mức độ hoàn thiện khác nhau sẽ có những loại kiểm thử tương ứng.
	-> Kiểm thử dựa trên sự hoàn thiện của hệ thống về phía code.
	
Kiểm tra code đúng bằng cách:
	- Kiểm thử tĩnh (Static Testing): không thực thi code mà chỉ đọc code bằng mắt và tư duy.
	- Kiểm thử động (Dynamic Testing): thực thi code để xem hành xử của hàm, hệ thống.
	
Có thể thấy, trước khi có code thì đã tiến hành kiểm thử (tài liệu, thiết kế...), nhưng phân loại này chỉ tập trung vào kiểm thử khi đã có code.
	-> Có 4 mức hoàn thiện của hệ thống, tương ứng với 4 giai đoạn / công đoạn / mức độ.

==========================================================================================

	[01. KIỂM THỬ ĐƠN VỊ - UNIT TEST]

** Kiểm thử đơn vị / thành phần (Unit / Component / Module Test): code được viết ra phải có khả năng kiểm thử được. 

	- Là một dạng kiểm thử tự động.
		+ Lập trình viên tự tiến hành kiểm thử từng đơn vị code mà mình vừa mới viết ra vì họ chính là những người am hiểu về code nhất.
		+ Một đơn vị (Unit) là thành phần nhỏ nhất có thể kiểm thử được. Nó có thể là một hàm (Function) / phương thức (Method), thủ tục (Procedure), lớp (Class), hoặc đối tượng (object)... vì chúng có liên quan đến xử lý dữ liệu.

	- Mục đích để đảm bảo chất lượng cho từng đơn vị code, mã nguồn viết cho đơn vị nào đó đúng với đặc tả yêu cầu và xác nhận rằng mã nguồn trong đơn vị đó có thể thực thi được. Vì từng thành phần nhỏ nhất được đảm bảo chất lượng thì mới có thể lắp ráp để trở thành một tính năng lớn.

	- Các lỗi tìm thấy và sửa trong giai đoạn kiểm thử đơn vị thường không cần ghi nhận vào trong tài liệu.

	-> Lập trình viên tự viết code để kiểm thử từng đơn vị code (có thể kiểm thử được) do chính mình viết ra
		(Viết code để kiểm thử code.)

		(Trung bình 10 dòng code được viết ra là đã tiềm ẩn lỗi.)

--------------------------------------------------------------------------------

	[NHỮNG CÁCH ĐỂ KIỂM THỬ ĐƠN VỊ]

* Những kỹ thuật để kiểm thử những hàm / lớp được viết ra:

------------------------------------------------------------

	0. Đọc code và hình thành tư duy trong đầu (Static Testing).

------------------------------------------------------------

	1. Tạo mới đối tượng, gọi hàm, truyền dữ liệu vào và xem kết quả: tự kiểm tra kết quả thủ công bằng mắt, có thể vẫn sẽ có sai sót, nhưng quan trọng nhất là sẽ không thể tận dụng được cho những mục đích trong tương lai (ví dụ: tận dụng trong quy trình tích hợp liên tục - CI).

		// Viết code để thử hàm / lớp ngay trong main()
		// { System.out.println(); }
		// { Console.WriteLine(); }

		-> Tự nhìn từng case bằng mắt để kết luận.

			Ví dụ: gọi hàm tính giai thừa và sout để so sánh kết quả bằng mắt.

				System.out.println("0! -> Mong đợi: 1; Thực tế: "
							+ MathUtil.getFactorial(0));

				System.out.println("1! -> Mong đợi: 1; Thực tế: "
							+ MathUtil.getFactorial(1));

				System.out.println("2! -> Mong đợi: 2; Thực tế: "
							+ MathUtil.getFactorial(2));

				System.out.println("5! -> Mong đợi: 120; Thực tế: "
							+ MathUtil.getFactorial(5));
				/*
					0! -> Mong đợi: 1; Thực tế: 1
					1! -> Mong đợi: 1; Thực tế: 1
					2! -> Mong đợi: 2; Thực tế: 2
					5! -> Mong đợi: 120; Thực tế: 12
				*/

				// Bên cạnh đó, nếu xuất hiện ngoại lệ
				// thì phải chủ động try-catch(),
				// nếu không thì ứng dụng sẽ bị ngắt

------------------------------------------------------------

	2. Ghi ra log file (.txt). Bản chất vẫn là gọi hàm để chạy nhưng kết quả sẽ in ra riêng một tập tin.
		-> Tự nhìn log file bằng mất để kết luận.

------------------------------------------------------------

	3. Sử dụng các framework (Unit testing framework): sử dụng thêm bộ thư viện khác (*.jar, *.dll...) để hỗ trợ kiểm thử các hàm / lớp và đưa ra một kết luận chung.

		- Lập trình viên sẽ sử dụng các thư viện kiểm thử trong lập trình để viết nên những đoạn code kiểm thử.
			+ Được đặt ở một thư mục / gói riêng và độc lập với code tính năng của hệ thống.
			+ Những đoạn code kiểm thử sẽ tự động thực thi các hàm, sau đó tự động so sánh kết quả và kết luận (báo cáo kết quả).
			+ Lúc này chỉ cần nhìn vào kết quả cuối cùng được trả về.

		- Những đoạn code kiểm thử do lập trình viên viết ra cũng sẽ được gọi là Test Case và sẽ có một kỹ thuật riêng để thiết kế ra các trường hợp / tình huống được gọi là kỹ thuật kiểm thử hộp trắng (White-box Testing).
	
		- Kỹ thuật này giúp tự động hoá việc kiểm tra kết quả, tích hợp / tham gia vào quy trình CI/CD và DevOps để tự động quyết định xem có cho ra được tập tin đóng gói hay không, đặc biệt hiệu quả đối với những hàm có cả đầu vào và đầu ra.
			-> Đảm bảo code luôn ổn dù đang ở trên máy cục bộ hay trên Server.

		- Các framework về Unit Test:
			+ C#: NUnit, MSTest, xUnit...
			+ Java: JUnit, TestNG...
			+ Python: pytest...

		-> Viết code để kiểm thử code.

--------------------

		* So sánh kết quả mong đợi (expected result) với kết quả thực tế (actual result):
			- Xanh: chạy đúng như mong đợi trong mọi trường hợp (có thể suy nghĩ và liệt kê ra).
				-> Phải luôn luôn đúng trong khả năng cho phép.
			- Đỏ: chỉ cần duy nhất 1 trường hợp chạy không đúng như mong đợi.
				-> Có sự thiếu ổn định trong quá trình hoạt động.

			-> Nếu xanh: đóng gói và tích hợp quy trình CI/CD.

		* Ưu điểm:
			- Giúp tách biệt giữa code chính và code test.
			- Tự động so sánh, tổng kết và thông báo kết quả.

----------------------------------------

		[PHÁT TRIỂN HƯỚNG KIỂM THỬ - TEST-DRIVEN DEVELOPMENT (TDD)]

		* Test-driven development (TDD) / Test First Development (Phát triển hướng đến kiểm thử): phát triển phần mềm luôn hướng về chất lượng bằng việc kiểm thử song song với lập trình.

			- Đây là kỹ thuật bắt nguồn từ phương pháp phát triển phần mềm eXtreme Programming (XP) và sau đó lan rộng sang các dạng khác nhau của Agile, để đáp ứng nhu cầu sớm có được sản phẩm phần mềm đạt chất lượng (không phải là thuật ngữ của kiểm thử).

			- Là quy trình yêu cầu ta phải luôn nghĩ đến việc thiết kế Test Case trước cả khi viết code chính (các hàm/lớp), để sản phẩm có chất lượng ngay trong quá trình viết code mà không cần mời nhóm QC/Tester tham gia vào trong giai đoạn này.

			- Vì muốn lập trình để giải quyết được một bài toán nào đó, thì điều đầu tiên và quan trọng nhất là phải biết cách giải bài toán ấy trong thực tế; nghĩa là đã có sẵn bộ dữ liệu mẫu thông qua việc tính toán thủ công rồi và nay chỉ việc áp dụng vào hàm/lớp sắp sửa kiểm thử.

			- Viết code chính song song với việc thiết kế Test Case hoặc thậm chí là thiết kế Test Case trước cả khi viết code chính, vì lúc này đã thống nhất với nhau về tên hàm/lớp.
				+ Suy nghĩ và đưa ra những tình huống (case) để thiết kế Test Case trước cả khi lập trình, sau khi đã có được bộ Test Case và thực thi nó một cách tự động thì sẽ đến bước lập trình ra những chương trình chạy đúng Test Case đã thiết kế.
				+ Kiểm thử đơn vị (Unit Test) chính là một dạng cụ thể của TDD khi yêu cầu lập trình viên phải có một bộ dữ liệu kiểm thử trước hoặc song song với từng đơn vị code.
				+ Giúp sớm phát hiện ra vấn đề và đảm bảo tính đúng đắn của hệ thống đến từ những đơn vị code nhỏ nhất.

			- Kỹ thuật này sẽ giúp rèn luyện ý thức khi lập trình, phải suy nghĩ về cách sử dụng hàm và những tình huống có thể xảy ra trong quá trình sử dụng, luôn luôn có một bộ dữ liệu để kiểm thử song hành với những dòng code, để mục tiêu duy nhất vẫn là code đạt chất lượng cao nhất và ứng dụng làm hài lòng khách hàng nhất có thể.

			- Phát triển hướng đến hành vi (BDD - Behavior-driven development) là một phần mở rộng của TDD.

			* Tóm tắt kỹ thuật TDD:
				1. Chuẩn bị thật kĩ bộ Test Case (áp dụng thêm các kỹ thuật kiểm thử để đưa ra đầy đủ các trường hợp sử dụng).
				2. Thiết kế kiểm thử trước.
				3. Chạy bộ Test -> Để ra kết quả đỏ (vì chưa có code xử lý).
				4. Bắt đầu viết code xử lý (đơn giản nhất có thể).
				5. Chạy lại Test -> Xem kết quả xanh hay đỏ.
				6. Khi đã xanh, tiếp tục sửa code (bổ sung / thay đổi theo hướng tích cực - Refactoring) cho đến khi kết quả xanh.
					[Cần đảm bảo code phải đơn giản, dễ hiểu và dễ bảo trì]
				7. Từ nay thoải mái sửa code, miễn là kết quả trước đó đang xanh, thì sau khi sửa xong cũng vẫn phải xanh.

			-> [Phát triển hướng kiểm thử] Thiết kế Test Case trước, sau đó viết code làm sao để PASS (xanh) được kết quả test.

--------------------

		[KIỂM THỬ HƯỚNG DỮ LIỆU - DATA-DRIVEN TESTING (DDT)]

		* Data-driven testing (DDT) / Table-driven testing / Parameterized testing (Kiểm thử hướng dữ liệu):

			- Các Framework dần trở thành một phần thiết yếu và góp một phần vào sự thành công của bất kỳ quy trình thử nghiệm tự động nào, khi vừa giảm chi phí bảo trì nhưng lại tăng hiệu quả kiểm thử.
			- Test Framework là tập hợp các quy tắc để thiết kế Test Script, mà kết quả cuối cùng là giảm thiểu việc chỉnh sửa mã kiểm thử khi ứng dụng thay đổi.
			
			-> Các quy tắc mà khi tuân thủ theo đúng thì sẽ cho ra kết quả tốt nhất.

				+ DDT là một trong các Test Automation Framework phổ biến nhất.
					* Linear Automation Framework
					* Modular / Module Based Framework
					* Library Architecture Framework
					* Data-Driven Framework
					* Keyword-Driven Framework
					* Hybrid Framework
					* Behavior-driven Development Framework

			- Khi có quá nhiều dữ liệu kiểm thử (kết quả mong đợi và kết quả thực tế) nằm lẫn lộn trong code, tạo nên sự khó khăn khi đọc code và bộ dữ liệu cũng khó được thay đổi trong tương lai.
				-> Khó kiểm soát được sự thiếu/đủ của các trường hợp kiểm thử.

			- Là phương pháp tham số hoá dữ liệu kiểm thử / kiểm thử hướng dữ liệu (chuyển đổi dữ liệu kiểm thử thành biến / tham số để truyền vào nơi gọi hàm).
				+ Tách hẳn bộ dữ liệu kiểm thử (gồm đầu vào và đầu ra) ra một nơi riêng.
				+ Dữ liệu kiểm thử sẽ được lưu riêng trong một tập tin (.txt, .csv...), mảng (trong code), bảng (CSDL) hoặc trang tính (spreadsheet)...
				+ Sau đó liên tục ánh xạ (map / extract / feed) bộ dữ liệu trở lại nơi gọi hàm (nơi assert) thay vì trộn lẫn dữ liệu kiểm thử chung với lời gọi hàm.
				+ Điều này sẽ giúp dễ dàng trong việc kiểm tra, bảo trì và nâng cấp dữ liệu kiểm thử.
				(Tách riêng code và dữ liệu kiểm thử.)

			- Ngoài ra, nhờ áp dụng kỹ thuật DDT và đã thống nhất với nhau về tên hàm từ trước, người thiết kế dữ liệu và người lập trình tính năng có thể là hai người độc lập.
				+ Người thiết kế các tính huống kiểm thử có thể viết trước các hàm để chuẩn bị dữ liệu, dựa theo tên hàm đã thống nhất.
				+ Từ đó giúp đảm bảo tính độc lập và khách quan trong quá trình làm việc.

			- Bên cạnh việc sử dụng trong cấp độ Unit Test, cơ chế này vẫn sử dụng được trong các cấp độ cao hơn, chẳng hạn như trong System Test hay UAT (chuẩn bị riêng một bộ dữ liệu và tự động hóa bằng Selenium).

			-> [Kiểm thử hướng dữ liệu] Phương pháp tách bộ dữ liệu kiểm thử sang một nơi riêng, sau đó truyền bộ dữ liệu từ bên ngoài vào code.

----------------------------------------

		[VIẾT UNIT TEST BẰNG JUNIT 4 TRÊN NETBEANS]

--------------------

		* Các bước chuẩn bị để viết Unit Test bằng NetBeans với JUnit 4 và Ant:

			Bước 01. Từ Source Packages -> New -> Other...

			Bước 02. Trong hộp thoại New File -> Categories: Unit Tests -> File Types: JUnit Test

			Bước 03. Đặt tên cho lớp và phải kết thúc bằng từ khóa "Test" (ví dụ: FactorialTest)

			Bước 04. Chọn Package, mặc định sẽ nằm trong package lớn là Test Packages để độc lập với nơi viết code

			Bước 05. [Tùy chọn] Nếu bị lỗi import thư viện
				05.01. Vào thư mục Test Libraries và xóa toàn bộ tập tin .jar trong đó
				05.02. Từ Test Libraries -> Add JAR/Folder
				05.03. Đi theo đường dẫn: C:\Program Files\NetBeans-số-phiên-bản\netbeans\platform\modules\ext
				05.04. Chọn 2 tập tin "hamcrest-core-1.3.jar" (hỗ trợ thực thi (???) và hiển thị kết quả xanh/đỏ) và "junit-4.13.1.jar" (cung cấp các hàm để kiểm thử và so sánh) để bắt đầu viết Unit Test bằng JUnit và kỹ thuật TDD.

--------------------

		* Viết code để kiểm thử code:

			* Lưu ý: Tên hàm phải nói lên mục đích của việc test (chia hàm ra theo mục đích test)
				Ví dụ:
					// Kiểm tra hàm tính giai thừa, khi đưa tham số đúng thì phải trả về kết quả đúng
					checkFactorialGivenCorrectArgumentReturnsWell

					// Kiểm tra hàm tính giai thừa, khi đưa tham số sai
					checkFactorialGivenWrongArgumentThrowsException
			
			* Từ khóa / Chú thích / Cú pháp / Kí hiệu / Quy tắc (Annotation): Giống như tên của một Interface, được sử dụng trước mỗi hàm. Vì vậy, phần thân hàm được ví như phần hiện thực hoá Interface.

			* Danh sách các từ khoá của bộ thư viện JUnit để máy ảo biết phải làm gì:
 
			@Test: để thông báo chuẩn bị hiện thực hoá việc Unit Test.

				- Khi lớp kiểm thử (được tạo bằng một Unit Testing Framework) được thực thi, nó sẽ chịu sự điều khiển của những thư viện kiểm thử, thư viện sẽ bằng một cách nào đó tự động tạo ra hàm main() để thực thi.
					+ Vì bản chất muốn thực thi được một lớp trong Java sẽ cần phải có một hàm main() để làm nơi bắt đầu.
					+ Chẳng hạn như trong lập trình Java web, để bắt đầu thì Servlet cũng sẽ được người dùng gọi, thông qua quá trình "Mapping Servlets to URL Patterns".
					+ Nhưng đối với lớp kiểm thử thì lại thiếu mất nơi bắt đầu. Vì vậy, kí hiệu @Test sẽ giúp biến một hàm bất kỳ trong một class bất kỳ thành hàm main() - nơi cuộc chơi (kiểm thử) bắt đầu, nếu thiếu thì sẽ được mặc định xem là một lớp bình thường.

				- Tóm lại, mỗi @Test sẽ tương đương với một hàm main().
					+ Trong một lớp có thể có nhiều @Test và mỗi lần một @Test được thực thi thì lớp sẽ được new một lần.
					+ Vì vậy, nếu muốn sử dụng kỹ thuật DDT để đưa bộ dữ liệu từ bên ngoài vào các hàm thì phải khai báo hàm DDT kèm từ khoá static với ý nghĩa dữ liệu kiểm thử sẽ nằm riêng một nơi và sử dụng chung giữa nhiều hàm @Test.

hha

				- Vì mỗi hàm là một cụm khác nhau, nên việc sử dụng từ khóa @Test là để báo hiệu rằng bộ dữ liệu kiểm thử nào sẽ được thực thi.

				-> Nơi thực sự chạy code để kiểm thử ứng dụng.

				// Hàm (bình thường) được đánh giá là xanh
				// khi tất cả các Test Case đều xanh,
				// chỉ cần duy nhất có 1 cặp actual ≠ expected
				// nghĩa là hàm xử lý không đúng hoặc ta kỳ vọng sai.

				// Ta cần xem lại code và kiểm thử lại
				// để đảm bảo xanh hết,
				// kết luận hàm ổn cho tất cả các tình huống đã kiểm thử.

				Assert: một lớp chứa các hàm static - hàm của JUnit, giúp hiển thị màu xanh / đỏ dựa trên việc so sánh giữa kết quả thực tế và kết quả mong đợi.
				Assert.assertEquals(expected, actual);

				Assert.assertEquals(5040, MathUtil.getFactorial(7));

			// * Bắt ngoại lệ (Exception):

			@Test(expected = IllegalArgumentException.class)

				// Ngoại lệ là 1 tình huống bất thường,
				// có khả năng xảy ra

				// Trong JUnit 4, ngoại lệ không phải là 1 giá trị
				// và không thể so sánh được,
				// nên không thể kiểm thử
				// theo cách thông thường (assertEquals),
				// mà chỉ có thể đo lường bằng cách
				// xem nó có xảy ra / xuất hiện hay không,

				// Để bắt được ngoại lệ trong JUnit 4,
				// ta sẽ thêm một thuộc tính (attribute) expected
				// vào bên trong kí hiệu @Test,
				// sau đó so sánh expected với một đối tượng
				// được tạo ra từ một lớp ngoại lệ (tênĐốiTượng.class)

				// Mặc dù bên trong hàm sẽ có nhiều bộ dữ liệu,
				// nhưng đối với ngoại lệ, chỉ cần một trường hợp xanh
				// thì cả hàm đó sẽ xanh, mặc kệ dù cho có trường hợp đỏ

				if (n < 0 || n > 20)
					throw new IllegalArgumentException("0 < n < 20");

				MathUtil.getFactorial(-5)

----------

			* Test Initializer & Finalizer: Những từ khoá đóng vai trò như những hàm khởi tạo hoặc dọn dẹp, luôn được thực thi theo một thứ tự ưu tiên và không quan trọng tên hàm hay vị trí hàm được khai báo.

				- Khi hàm kiểm thử @Test được thực thi thì những hàm đặc biệt này sẽ được ưu tiên chạy trước hoặc chạy cuối cùng.

				- Có nhiệm vụ khởi động các đối tượng, dữ liệu, tạo kết nối CSDL hoặc dọn dẹp, gỡ bỏ kết nối CSDL...

				- Trong khi đó, cú pháp @Test được sử dụng chỉ để chạy riêng các tình huống, thực thi code chuẩn bị kiểm thử theo thứ tự từ trên xuống dưới.

				-> Sử dụng kí hiệu / từ khoá đặc biệt để quy định thứ tự thực thi.

				* Bảng so sánh kí hiệu giữa JUnit 4 và JUnit 5 (Jupiter):

			+-----------------------------------------------------------------------------+
			¦		Feature				¦   JUnit 4    ¦   JUnit 5    ¦
			¦						¦              ¦  (Jupiter)   ¦
			¦-----------------------------------------------+--------------+--------------¦
			¦ - Execute before all @Test methods		¦ @BeforeClass ¦ @BeforeAll   ¦
			¦   of the class are executed.			¦              ¦              ¦
			¦						¦              ¦              ¦
			¦ - Used with static method.			¦              ¦              ¦
			¦						¦              ¦              ¦
			¦ - For example, This method could contain	¦              ¦              ¦
			¦   some initialization code.			¦              ¦              ¦
			¦-----------------------------------------------+--------------+--------------¦
			¦ - Execute after all @Test methods		¦ @AfterClass  ¦ @AfterAll    ¦
			¦   in the current class.			¦              ¦              ¦
			¦						¦              ¦              ¦
			¦ - Used with static method.			¦              ¦              ¦
			¦						¦              ¦              ¦
			¦ - For example, This method could contain	¦              ¦              ¦
			¦   some cleanup code.				¦              ¦              ¦
			¦-----------------------------------------------+--------------+--------------¦
			¦ - Execute before each @Test method.		¦ @Before      ¦ @BeforeEach  ¦
			¦						¦              ¦              ¦
			¦ - Used with non-static method.		¦              ¦              ¦
			¦						¦              ¦              ¦
			¦ - For example, to reinitialize		¦              ¦              ¦
			¦   some class attributes used by the methods.	¦              ¦              ¦
			¦-----------------------------------------------+--------------+--------------¦
			¦ - Execute after each @Test method.		¦ @After       ¦ @AfterEach   ¦
			¦						¦              ¦              ¦
			¦ - Used with non-static method.		¦              ¦              ¦
			¦						¦              ¦              ¦
			¦ - For example, to roll back			¦              ¦              ¦
			¦   database modifications.			¦              ¦              ¦
			+-----------------------------------------------------------------------------+

			* Sơ đồ tóm tắt:

				+--------------+			│
				¦ @BeforeClass ¦			│
				+--------------+			│
									│
					+--------------+		│
					¦   @Before    ¦		│
					+--------------+		│
									│ Trình
						+――――――――――――――+	│ tự
						│    @Test     │	│ thực
						+――――――――――――――+	│ thi
									│
					+--------------+		│
					¦    @After    ¦		│
					+--------------+		│
									│
				+--------------+			│
				¦ @AfterClass  ¦			│
				+--------------+			v


				* Diễn giải bằng văn bản:

			- Test Initializer | setUp() / @Before: được thực thi trước những hàm @Test khác, có thể được thực thi nhiều lần, miễn là vẫn trước các hàm @Test khác. Có thể tận dụng để luôn tạo mới một đối tượng đại diện cho trình duyệt trước mỗi lần chạy.
				-> Tài lanh và luôn chạy trước mỗi hàm @Test, chạy nhiều lần nếu có nhiều hàm @Test.

				Ví dụ: chuẩn bị dữ liệu...

			- Test Finalizer | tearDown() / @After: được thi sau những hàm @Test khác, có thể được thực thi nhiều lần, miễn là vẫn sau các hàm @Test khác.
				-> Ân cần và luôn chạy sau mỗi hàm @Test, chạy nhiều lần nếu có nhiều hàm @Test.

				Ví dụ: dọn dẹp dữ liệu...

			- Test Class Initializer | setUpClass() / @BeforeClass: được thực thi đầu tiên và một lần duy nhất, trước tất cả các hàm @Test khác trong lớp.
				+ Vì vậy, có thể tách thao tác ra thành một hàm riêng và đảm bảo hàm này luôn chạy trước tất cả các hàm @Test khác.
				+ Thường được sử dụng để khởi động giá trị.
				-> Chạy trước tất cả các hàm @Test để "làm gương" / "dẫn đường" một lần duy nhất.

				Ví dụ:
					- Khởi động trình duyệt và trang web: System.setProperty(), chromeDriver.get()...
					- Mở kết nối với CSDL để lấy dữ liệu.

			- Test Class Finalizer | tearDownClass() / @AfterClass: được thực thi cuối cùng và một lần duy nhất, sau khi tất cả các hàm @Test trong lớp đã được thực thi.
				+ Vì vậy, có thể tách thao tác ra thành một hàm riêng và đảm bảo hàm này chỉ chạy sau khi tất cả các hàm @Test đều đã được thực thi xong.
				+ Thường được sử dụng để đóng các kết nối.
				-> Ở lại cuối cùng để "dọn dẹp hậu trường" một lần duy nhất.

				Ví dụ:
					- Tắt trình duyệt sau khi đã kiểm thử xong tất cả các Test Case: chromeDriver.close() và chromeDriver.quit().
					- Xoá dữ liệu rác và đóng kết nối CSDL.
					- Gán giá trị NULL cho các biến.

			// * Kỹ thuật tham số hoá (Parameterized):

			@RunWith(value = Parameterized.class): thông báo cho máy ảo Java (thư viện JUNit) rằng class này đã được tham số hóa, trong quá trình thực thi cần có trích xuất dữ liệu.

			public class AdvancedFactorialTest {

				// @Parameters: Báo cho JUnit biết đây là dữ liệu nguồn.
				//	- Là tập hợp tham số dùng để truyền vào hàm assert().
				//	- Hãy trích xuất dữ liệu từ đây để đưa vào @Parameter.

				@Parameters

				// Khai báo tập hợp các tham số
				// là mảng 2 chiều kiểu Object
				// (vì các Framework thường sẽ chơi với Object),
				// đi kèm từ khoá static để dữ liệu nằm cố định
				// và mọi nơi đều có thể sử dụng được,
				// lặp lại cho nhiều tình huống kiểm thử khác nhau
				public static Object[][] initData() {

					// Để sử dụng, cần phải biến dữ liệu thành đối tượng
					// bằng cách tạo mới đối tượng với từ khoá new()
					// và thuộc lớp đóng gói (Wrapper Class) số nguyên
					return new Integer[][] {
								// Dữ liệu đầu vào - Kết quả mong đợi
								{0, 1},
								{1, 1},
								{7, 5040},
								{18, 6402373705728000},
								{19, 121645100408832000},
							       };
				}

			

				// @Parameter: Tương ứng với từng tham số con của @Parameters
				//	       (từng phần tử trong tập hợp các tham số),
				//	       báo cho JUnit 4 biết cách lấy từng dữ liệu
				//	       với ý nghĩa do người thiết kế tự quy định.
				//
				//	Ví dụ: Báo cho JUnit, mỗi dòng dữ liệu
				//	       trong mảng 2 chiều gồm 2 cột với 2 ý nghĩa:
				//		- Cột 0 là dữ liệu đầu vào
				//		- Cột 1 là kết quả mong đợi

				@Parameter

				// Chuẩn bị 2 biến là thuộc tính non-static
				// (riêng biệt cho từng đối tượng khác nhau),
				// vì mỗi hàm kiểm thử khác nhau
				// khi được thực thi sẽ là một ngữ cảnh khác nhau,
				// được xem là một đối tượng độc lập
				// với những thuộc tính riêng biệt

				// Ánh xạ input với cột 0 trong mảng
				@Parameter(value = 0)
				public int input;
				
				// Ánh xạ expected với cột 1 trong mảng
				@Parameter(value = 1)
				public long expected;

				// Nhận bộ dữ liệu kiểm thử,
				// tự động duyệt và lặp qua các bộ dữ liệu
				// trong hàm initData() ở bên trên
				// và tự động tiến hành kiểm thử
				// (dành cho trường hợp tham số đúng, kết quả "xanh")
				@Test
				public void checkFactorialGivenCorrectArgumentReturnsWell() {

					//long actual = getFactorial(input);
					assertEquals(expected, getFactorial(input));
				}
			}

----------------------------------------

		[VIẾT UNIT TEST BẰNG JUNIT 5 (JUPITER) TRÊN NETBEANS]

--------------------

		* Các bước chuẩn bị để viết Unit Test bằng NetBeans với JUnit 5 (Jupiter) và Maven:

			Bước 01. Truy cập kho Maven Central Repository và tìm kiếm với từ khoá Jupiter hoặc JUnit 5

				JUnit Jupiter API
				JUnit Jupiter Engine
				JUnit Jupiter Params: phục vụ cho việc kiểm thử hướng dữ liệu (Data-driven testing - DDT)
					-> JUnit Jupiter (Aggregator) | Tổng hợp

			Bước 02. Lựa chọn phiên bản (những phiên bản không có chữ thường sẽ là những phiên bản đã ổn định)
				RC (Release candidate): nằm trong giai đoạn hậu beta, là ứng viên sáng giá cho giai đoạn phát hành cuối cùng.
				M (Milestone): phiên bản đánh dấu một cột mốc quan trọng của dự án.

			Bước 03. Chọn công cụ Maven và sao chép toàn bộ câu lệnh khai báo thư viện

			Bước 04. Trong vùng <project>, song song / ngang hàng với vùng <properties>, nhập thêm cặp thẻ <dependencies></dependencies> (dạng số nhiều). Sau đó dán câu lệnh khai báo những thư viện cần sử dụng (mà trước đó đã sao chép trên Central Repository) vào bên trong cặp thẻ <dependencies></dependencies>
					-> Thư viện được sử dụng để tham chiếu vào code.

				Ví dụ: khai báo thư viện JUnit 5 (Jupiter)

					<properties>
					    ...
					</properties>

					<dependencies>

					    <!-- Khai báo dependency tại đây -->
					    <dependency>
						<groupId>org.junit.jupiter</groupId>
						<artifactId>junit-jupiter</artifactId>
						<version>5.8.2</version>
						<scope>test</scope>
					    </dependency>

					</dependencies>

			Bước 05. Trong vùng <project>, song song / ngang hàng với vùng <properties>, nằm ngay phía sau phần <dependencies>, nhập thêm cặp thẻ <build></build> và cặp thẻ <plugins></plugins> (dạng số nhiều) ở bên trong vùng <build>. Sau đó khai báo thêm plugin hỗ trợ cho việc chạy Unit Test, tuy đây là một bộ thư viện dependency nhưng lại sử dụng như plugin, vì vậy, phải bỏ cặp thẻ <dependency></dependency> sau khi sao chép và dán. Đây cũng là một tập tin *.jar giống như thư viện, nhưng nó sẽ được thực thi cùng với IDE, maven, JDK, JVM..., để thực thi đoạn code có sử dụng thư viện Unit Test đã khai báo.
					-> Thư viện được sử dụng để thực thi code.

				Ví dụ: khai báo plugin Maven Surefire

					<properties>
					    ...
					</properties>

					<dependencies>
					    ...
					</dependencies>

					<build>
					    <plugins>

						<plugin>

						    <!-- Khai báo plugin tại đây -->
						    <groupId>org.apache.maven.plugins</groupId>
						    <artifactId>maven-surefire-plugin</artifactId>
						    <version>3.0.0-M7</version>

						    <!-- Cấu hình quá trình build mà không cần chạy bộ test -->
						    <configuration>
						        <skipTests>true</skipTests>
						    </configuration>

						</plugin>

					    </plugins>
					</build>

			Bước 06. Nhấp tổ hợp [Alt]+[Shift]+[F] để tự động căn chỉnh lại mã nguồn (trong NetBeans)

			Bước 07. Nhấn nút Clean and Build Project ([Shift]+[F11]) để tải thư viện và plugin vừa mới khai báo về

--------------------

		* Viết code để kiểm thử code:

			// * Kỹ thuật tham số hoá (Parameterized):
   
			@ParameterizedTest // Đã bao gồm @RunWith và @Test

				// Nhận bộ dữ liệu kiểm thử và tự động tiến hành kiểm thử
    
			@MethodSource("tênHàmChứaBộDữLiệuDạngThamSốHoá")

				// Sử dụng dữ liệu được lấy từ hàm tênHàmChứaBộDữLiệuDạngThamSốHoá()

			public void tênHàmThựcHiệnKiểmThử(int biếnĐượcKhaiBáoBênTrongHàm) {...}

				// Khai báo biến trực tiếp bên trong hàm
				// các biến để hứng bộ dữ liệu và truyền vào hàm,
				// thay vì phải khai báo rời ở bên ngoài hàm

			// * Bắt ngoại lệ (Exception):

			@Test
			public void tênHàmThựcHiệnKiểmThử() {
				
				// Được chia ra làm hai vế:
				//	1. Lớp chứa ngoại lệ
				//	2. Câu lệnh (hàm) gây ra ngoại lệ
				//		(Phải được truyền vào dưới dạng đối tượng,
				//		 có thể sử dụng biểu thức lambda để tạo nhanh)
				assertThrows(TênLớpChứaNgoạiLệ.class, tênĐốiTượngGâyRaNgoạiLệ);
			}

==========================================================================================


	[02. KIỂM THỬ TÍCH HỢP - INTEGRATION TEST]

** Kiểm thử tích hợp (Integration Test): kiểm thử viên hoặc lập trình viên sẽ thực hiện kiểm thử.
	- Các thành phần riêng lẻ (các hàm, lớp, mô-đun) đang hoạt động tốt, các hệ thống bên ngoài... sẽ được tích hợp lại với nhau (gọi thông qua API...) để xem khi trở thành một cụm chức năng (nhưng chưa thành một ứng dụng hoàn chỉnh) có tương thích và hoạt động/gọi/tương tác đúng hay không.
	- Hoặc kiểm thử khi Back-end được kết hợp với Front-end. Stub và Driver được sử dụng để hỗ trợ cho quá trình này.

	-> Kiểm thử khi các hàm / lớp / mô-đun, sử dụng hệ thống bên ngoài thông qua API, khi Back-end và Front-end... được gom thành một cụm chức năng mà người dùng có thể trải nghiệm.
		(Kiểm thử sự tương tác giữa các đơn vị / thành phần code hoặc giữa các hệ thống / microservice - API / web service.)

	Ví dụ:
		// Lắp ráp các lớp (class)
		DAO + DTO + DBUtil
			// Kết nối với phần mềm bên thứ ba
			// chẳng hạn như Google mail, Facebook, Paypal...

			// Kết nối với API, thư viện Jersey...

			-> Chức năng thêm-xoá-sửa-tìm kiếm.

--------------------------------------------------------------------------------

	[CÁC CHIẾN LƯỢC TÍCH HỢP]

	* Chiến lược tích hợp các đơn vị/thành phần:

------------------------------------------------------------

		- Chiến lược Big-bang: đợi đến khi hoàn thành xong tất cả các đơn vị/thành phần hoặc hệ thống (bên ngoài) thì mới tích hợp cùng một lúc để có hệ thống đầy đủ.
			(Khó có thể xác định được thành phần xảy ra lỗi.)

------------------------------------------------------------

		- Chiến lược Incremental (tăng dần): tại một thời điểm, chỉ tích hợp một đơn vị/thành phần hoặc hệ thống (bên ngoài) nhỏ. Chiến lược này kiểm thử từng phần riêng biệt, giúp sớm phát hiện lỗi và dễ dàng cô lập để tìm ra nguyên nhân.
			(Sẽ gặp trường hợp tình năng này chờ tính năng kia phát triển. Lúc này, cần phát triển thêm các Stub & Driver để có thể thực hiện kiểm thử trước khi tính năng thật được hoàn thành.)

			* Hai chiến lược incremental thường được sử dụng là top-down và bottom-up:

----------------------------------------

				- Chiến lược top-down: hệ thống được xây dựng theo từng giai đoạn, bắt đầu từ thành phần cao nhất (top) gọi các thành phần khác ở cấp thấp hơn. Các mô-đun chính/quan trọng (cấp cao hơn) sẽ được ưu tiên kiểm thử trước rồi mới kiểm thử đến các mô-đun phụ (cấp thấp hơn). Các mô-đun phụ (cấp thấp hơn) chưa xây dựng thì sẽ được tạm thời thay thế bằng Stub. Sau đó, các mô-đun này sẽ được tích hợp lại với nhau. Thường được thực hiện trên các ngôn ngữ lập trình hướng cấu trúc/thủ tục, không quá phức tạp và chỉ có lợi nếu lỗi nghiêm trọng xảy ra ở đầu chương trình.
					-> Thiết kế và kiểm thử những mô-đun chính trước, sau đó mới đến các mô-đun phụ.

----------------------------------------

				- Chiến lược bottom-up: chiến lược này ngược lại với chiến lược top-down, các thành phần được tích hợp theo thứ tự từ dưới lên. Khi kiểm thử, các mô-đun phụ (cấp thấp hơn) sẽ được ưu tiên kiểm thử trước rồi mới đến các mô-đun chính (cấp cao hơn). Các mô-đun chính (cấp cao hơn) chưa xây dựng sẽ được tạm thời thay thế bằng Driver. Sau đó, các mô-đun này sẽ được tích hợp lại với nhau. Thường được thực hiện trên các ngôn ngữ lập trình hướng đối tượng, sự phức tạo cao với nhiều dữ liệu và chỉ có lợi nếu các lỗi nghiêm trọng xảy ra ở cuối chương trình.
					-> Thiết kế và kiểm thử những mô-đun phụ trước, sau đó mới đến các mô-đun chính.

==========================================================================================

	[03. KIỂM THỬ HỆ THỐNG - SYSTEM TEST]

** Kiểm thử hệ thống (System Test): do đội ngũ tester độc lập thực hiện để đảm bảo tính khách quan bằng các kỹ thuật kiểm thử hộp đen (black-box testing).

	- Thực hiện khi các thành phần đã được tích hợp thành một hệ thống hoàn chỉnh, môi trường để kiểm thử là một môi trường giả lập (không thể giống thực tế hoàn toàn).

	- Kiểm tra về tổng thể mọi mặt của hệ thống có tuân thủ các đặc tả yêu cầu của người dùng (requirement).
		+ Thực hiện kiểm thử theo toàn bộ những đặc tả yêu cầu (kiểm thử cả hệ thống) - khi tích hợp nhiều mô-đun lại với nhau.
		+ Đặc tả yêu cầu thường chứa các yêu cầu chức năng (functional requirement) và các yêu cầu phi chức năng (non-functional requirement) cần được kiểm thử.

	-> Kiểm thử khi những chức năng được tổng hợp thành một hệ thống và tạm sử dụng được.

	Ví dụ: Giao diện đồ họa người dùng (GUI) + API + Back-end + các trang
		-> Một hệ thống gần như hoàn hảo.

--------------------------------------------------------------------------------

	[PHÂN LOẠI YÊU CẦU PHẦN MỀM]

	* Yêu cầu chức năng (Functional Requirement): các yêu cầu chỉ định các chức năng của hệ thống hoặc các thành phần cần được thực hiện, nó chỉ định chi tiết những gì (WHAT) hệ thống cần làm. Trong suốt quá trình kiểm thử chức năng, ta cần thực hiện các kiểm tra chức năng như: cài đặt, chạy thử ứng dụng trên máy cục bộ, hệ điều hành cục bộ, kiểm tra các chức năng của ứng dụng, các xử lý chuỗi, văn bản như sao chép (copy), dán (paste) cho các ký tự mở rộng,...

------------------------------------------------------------

	* Yêu cầu phi chức năng (Non-Functional Requirement): những yêu cầu không liên quan đến dịch vụ được chỉ định, mà liên quan đến những thuộc tính ràng buộc hệ thống, chất lượng và trải nghiệm:
		+ Kiểm thử tính tin cậy (Reliabilty Tesing).
		+ Kiểm thử tính hiệu quả (Efficiency Testing).
		+ Kiểm thử tính tiện dụng (Usablilty Testing).
		+ Kiểm thử khả năng bảo trì (Maintainablity Testing).
		+ Kiểm thử tính khả chuyển (Portable Testing).
		+ Kiểm thử hiệu năng (Performance Testing).

==========================================================================================

	[04. KIỂM THỬ CHẤP NHẬN - USER ACCEPTANCE TEST]

** Kiểm thử chấp nhận (User Acceptance Test - UAT): trước khi đưa vào thực tế, quan trọng nhất vẫn là cần đưa cho khách hàng sử dụng thử và nhận phản hồi.

	- Được thực hiện bởi những cá nhân hoặc tổ chức có quyền lợi nhất định đối với hệ thống đang phát triển.
		+ Là những người dùng cuối và có thể là bất kì ai có nhu cầu sử dụng phần mềm, chẳng hạn như: chủ doanh nghiệp, người quản lý, giám đốc điều hành, khách hàng... (là những người cung cấp yêu cầu, hướng dẫn, phản hồi về thiết kế và chức năng... trong suốt quá trình phát triển).
		+ Được thực hiện trong chính môi trường thực tế hoặc gần giống thực tế nhất.
		+ Kiểm thử chỉ tập trung vào các yêu cầu nghiệp vụ (Business Requirement) và mục tiêu kinh doanh (Business Objective / Business Goal) của người sử dụng.

	- Giúp đảm bảo sản phẩm phần mềm hoạt động đúng những gì khách hàng mong đợi, đáp ứng nhu cầu trong công việc và không gặp quá nhiều khó khăn trong quá trình sử dụng, khách hàng hài lòng và chấp nhận sản phẩm – thanh toán hợp đồng.

	- Ngoài ra, việc thu thập thói quen sử dụng phần mềm của người dùng cũng là một hình thức UAT.

	-> Quyết định sản phẩm đúng với yêu cầu và khách hàng sẵn sàng thanh toán hợp đồng.

------------------------------------------------------------

	[CÁC DẠNG KIỂM THỬ CHẤP NHẬN]

	* Alpha Test: người trong công ty (in-house) - cả lập trình viên và kiểm thử viên, những bên có liên quan (stakeholders) hoặc một đội ngũ kiểm thử độc lập đóng vai trò người dùng phía khách hàng.
		- Tiến hành kiểm thử trong môi trường phát triển, sau đó phản hồi lại cho lập trình viên về những lỗi gặp phải trong quá trình sử dụng.
		- Được kiểm thử với nhiều kịch bản khác nhau để tìm và vá lỗi trước khi đưa sang Beta Test.

	* Beta Test: công khai đưa cho những người từ phía khách hàng (external).
		- Khách hàng dùng thử sản phẩm trong môi trường thực tế của chính họ và đưa ra phản hồi trước khi phát hành phiên bản chính thức.
		- Mục đích là để đánh giá khả năng đáp ứng các yêu cầu nghiệp vụ, hiệu suất, độ tin cậy, khả năng sử dụng và khả năng tương thích của hệ thống trong những tình huống thực tế.
		- Phiên bản dùng thử thường được phân phối thông qua hình thức phát hành miễn phí hoặc mời tham gia trải nghiệm tại một hội thảo nào đó.
		- Beta Test có thể được thực hiện sau Alpha Test hoặc không cần đến Alpha Test.

--------------------------------------------------------------------------------

[GÓC NHÌN CỦA NGƯỜI DÙNG]

Ngoại trừ Unit Test, 3 cấp độ còn lại của việc kiểm thử (Integration Test, System Test, User Acceptance Test - UAT) đều được thực hiện khi phần mềm đã thành hình, đó là khi code được ráp với giao diện người dùng (UI) hoặc khi chức năng đã ổn định. Lúc này, ta sẽ chuyển sang kiểm thử dưới góc nhìn của người dùng.

	- Góc nhìn của người dùng: sẽ có giao diện / màn hình với các trang, biểu mẫu... để người dùng có thể tương tác và nhập dữ liệu vào, nhấn nút và xem kết quả trả về (có thể là điều hướng sang một trang khác).

	- Người dùng không quan tâm phần "hậu trường" (các hàm được chạy đằng sau UI), mà chỉ quan tâm họ làm được gì với hệ thống.

	-> Góc nhìn của người dùng là góc nhìn về mặt tính năng, không còn quan tâm về mặt xử lý.

==========================================================================================

	[TỔNG KẾT VỀ PHÂN LOẠI THEO MỨC ĐỘ / CẤP ĐỘ]

Lập trình viên: Xây dựng hệ thống (ngay từ những "viên gạch đầu tiên").
		|
		|
		|
		|
		V
	-----------------	-----------------	-----------------
	| Hàm, Lớp	| ----> | Tính năng	| ----> | Hệ thống	|
	-----------------	-----------------	-----------------
					^
					|
			-----------------
			|
			|
Kiểm thử viên: Kiểm thử hệ thống (sau khi hệ thống đã bắt đầu "thành hình").

==========================================================================================
==========================================================================================
==========================================================================================

[02. PHÂN LOẠI THEO LOẠI - TESTING TYPE]

** Loại kiểm thử (Testing Type): Một nhóm các hoạt động để đạt được một mục tiêu/mục đích, đối tượng kiểm thử cụ thể.

--------------------------------------------------------------------------------

[Góc nhìn 1]

Tương ứng với từng cấp độ (level) kiểm thử sẽ có thể có một loại (type) kiểm thử.

* Phân chia loại kiểm thử theo ISTQB:

	01. Kiểm thử hộp đen (Black Box Testing)
		01.01. Kiểm thử chức năng (Functional Testing)
		01.02. Kiểm thử phi chức năng (Non-Functional Testing)

	02. Kiểm thử hộp trắng (White Box Testing)

	03. Kiểm thử khi có sự thay đổi (Change Related Testing)

Nghĩa là mỗi cấp độ (level) kiểm thử sẽ có thể có một hoặc tất cả (nhưng không bắt buộc phải có tất cả) các loại (type) kiểm thử.

--------------------------------------------------------------------------------

[Góc nhìn 2]

Khi đã có hệ thống rồi, ta sẽ không còn kiểm thử ở các cấp độ (level - mức hoàn thiện của hệ thống) mà chuyển sang kiểm thử ở dạng (type), để kiểm tra xem các chức năng (kèm GUI) có hoạt động đúng và tiện dụng cho người dùng hay không.
	- Không còn nhìn ở cấp độ thấp: phần xử lý hậu trường của ứng dụng, mà chỉ nhìn ở mức độ cao: tính năng này có trả về kết quả như mong đợi.
	- Bằng cách đọc các Đặc tả yêu cầu phần mềm (SRS), Yêu cầu phần mềm của người dùng (User Story)... để hiểu thật rõ về phần mềm (một cách tổng quát).
	- Sau đó áp dụng phương pháp (method) kiểm thử hộp đen (black-box testing) để thiết kế Test Case.

	-> Kiểm thử khi chức năng hoàn thiện (kèm GUI).

* Phân chia loại kiểm thử theo góc nhìn này:

	01. Kiểm thử chức năng (Functional Testing)

	02. Kiểm thử phi chức năng (Non-Functional Testing)

	03. Kiểm thử khi có sự thay đổi (Change Related Testing)

Nghĩa là mỗi cấp độ (level) kiểm thử sẽ có thể có một hoặc tất cả (nhưng không bắt buộc phải có tất cả) các loại (type) kiểm thử.

------------------------------------------------------------

	Ví dụ: phân biệt cách kiểu phân loại
		- Type: GUI
		- Method: manual

==========================================================================================

	[01. KIỂM THỬ CHỨC NĂNG - FUNCTIONAL TESTING]

** Kiểm thử chức năng (Functional Testing): dựa theo các yêu cầu chức năng (functional requirement) của hệ thống.
	- Kiểm tra tiến trình làm phần mềm: requirements (đúng / sai / bất hợp lý - đủ / thừa / thiếu).
	- Kiểm tra những chức năng đã thiết kế có hoạt động đúng.

	-> Kiểm thử tính năng của phần mềm (tính đầy đủ, đúng đắn và phù hợp).

		Ví dụ 1: kiểm tra giới hạn số lần nhập sai mã pin để tránh trường hợp bị mất tiền do đánh rơi thẻ.

		Ví dụ 2: kiểm tra thực hiện một phép tính trên ứng dụng máy tính bỏ túi của Windows.

==========================================================================================

	[02. KIỂM THỬ PHI CHỨC NĂNG - NON-FUNCTIONAL TESTING]

** Kiểm thử phi chức năng (Non-Functional Testing): dựa theo các yêu cầu phi chức năng (non-functional requirement) của hệ thống.
	- Kiểm tra chất lượng về mặt trải nghiệm của người dùng: nhanh/chậm - tốt/tệ - đẹp/xấu.

		-> Kiểm thử trải nghiệm của người dùng về phần mềm (tính đáng tin cậy, hiệu quả, bảo mật, khả năng tương thích và tính khả dụng).

		Ví dụ 1: kiểm tra tốc độ phản hồi của hệ thống khi xử lý 1 nút nhấn (Performance Testing).

		Ví dụ 2: kiểm tra xem hệ thống chịu được bao nhiêu người dùng truy cập cùng một lúc để xử lý trong khoảng thời gian cao điểm, ví dụ: đăng ký môn học,... (Load Testing).

--------------------------------------------------------------------------------

	[KIỂM THỬ HIỆU NĂNG - PERFORMANCE TESTING]

	** Kiểm thử hiệu năng (Performance Testing): nhằm xác định một số vấn đề về thắt cổ chai (bottleneck) hoặc hiệu năng của hệ thống khi số lượng người dùng bắt đầu nhiều.
		-> Kiểm tra độ ổn định và tốc độ phản hồi của ứng dụng

	* Cần kiểm thử về:
		- Speed: tốc độ và thời gian hệ thống phản hồi cho người dùng nhanh hay chậm, có ổn định hay không.

		- Capacity: sức chứa số lượng người truy cập cùng một lúc.

		- Stability: tính ổn định theo thời gian dài dưới các tải (load) khác nhau.

		- Scalability: khả năng tự động co giãn (hạ tầng, tối ưu mã nguồn) của hệ thống để đáp ứng nhu cầu của người dùng.

------------------------------------------------------------

		[CÁC LOẠI KIỂM THỬ HIỆU NĂNG]

----------------------------------------

		- Tính bền vững (Endurance Testing): kiểm tra hành vi của hệ thống với lượng tải đáng kể được thực hiện trong một khoảng thời gian dài. Sự tiêu thụ bộ nhớ thường là nguyên nhân dẫn đến failure của hệ thống.

			Ví dụ: một chức năng vẫn hoạt động tốt khi thực hiện kiểm thử trong 1 giờ, nhưng cũng cùng yêu cầu đó nếu thực hiện liên tục trong 3 giờ thì hệ thống phát sinh vấn đề do rò rỉ bộ nhớ (Leak Memory).

----------------------------------------

		- Sức chứa (Volume Testing/Capacity): kiểm thử hệ thống với một lượng dữ liệu nhất định, sức tải mà CSDL cho phép.

----------------------------------------

		- Chịu tải (Load Test): kiểm tra khả năng chịu tải của phần mềm thực hiện bằng cách chạy hàng loạt các bài kiểm tra, tăng dần và liên tục sức tải cho đến khi hệ thống không thể thực thi được nữa. Mục đích để biết được cách hành xử của hệ thống khi nó quá tải và phát hiện những lỗi mà không thể phát hiện ở các trường hợp thông thường. Với cách tiếp cận này, Test Case thường được thiết kế xung quanh giá trị biên (cận biên lớn nhất) để xác định mức độ tắc nghẽn hiệu suất.
			-> Kiểm tra khi lượng tải (load) ít hơn hoặc bằng số lượng được thiết kế ban đầu.

			Ví dụ: đặc tả yêu cầu phần mềm nêu rằng hệ thống có khả năng chịu tải 300 giao tác trên một giây thì ban đầu kiểm tra dưới 300 giao tác trên giây, và sau đó tăng dần cho đến khi hệ thống không thể thực thi được nữa để xác minh rằng ứng dụng đang phản hồi trong vòng 3 giây cho tất cả giao tác.

----------------------------------------

		- Chịu rủi ro (Stress Test): kiểm tra hệ thống với những giá trị ngoài phạm vi đã được thiết kế (abnormal conditions). Mục đích để xác định những điểm giới hạn/gãy (breaking point) của hệ thống và theo dõi cách hệ thống phục hồi.
			-> Kiểm tra khi lượng tải (load) nhiều hơn số lượng được thiết kế ban đầu.

			Ví dụ: ứng dụng có thể xử lý 1000 người dùng cùng một lúc với thời gian phản hồi là 4 giây, Stress Test có thể được thực hiện bằng cách áp dụng tải hơn 1000 người dùng. Thử nghiệm ứng dụng với 1100, 1200, 1300 người dùng và xem xét thời gian phản hồi.

----------------------------------------

		- Tính mở rộng (Scalability): kiểm thử để đo khả năng mở rộng cho các yêu cầu phi chức năng.
			-> Kiểm tra khi lượng tải (load) nhiều hơn số lượng được thiết kế ban đầu.

==========================================================================================

	[03. KIỂM THỬ KHI CÓ SỰ THAY ĐỔI - CHANGE-RELATED TESTING]

** Kiểm thử khi có sự thay đổi (Change-related Testing):

--------------------------------------------------------------------------------

	* Kiểm thử xác nhận (Retesting / Confirmation Testing): Sau khi phát hiện lỗi và báo cáo lỗi, thực hiện kiểm thử xác nhận để đảm bảo lỗi đã thực sự được sửa.

		- Kiểm thử viên phát hiện ra lỗi (bug) và báo cáo cho lập trình viên để sửa lỗi.
			+ Sau khi sửa/thay đổi trong mã nguồn xong, lập trình viên sẽ giao cho kiểm thử viên kiểm tra lại (verify) ở phiên bản hiện tại.
			+ Trước đó xảy ra lỗi ở đâu, thì nay kiểm tra lỗi đúng ngay ở đấy.

		- Nhằm xác minh rằng vấn đề đã thực sự được giải quyết theo đúng với những gì đã được báo cáo hay chưa.

		- Đây là điều hiển nhiên và là quy trình thường xuyên xảy ra.

		-> Phát hiện lỗi > Báo lỗi > Sửa lỗi > Xác minh rằng lỗi đã được sửa theo đúng báo cáo ban đầu hay chưa - diễn ra trong đúng phạm vi của lỗi đó.
			(Kiểm tra xem liệu lỗi đã báo cáo có thực sự được sửa hay chưa.)

--------------------------------------------------------------------------------

	* Kiểm thử hồi quy (Regression Testing): Xác minh rằng những thay đổi của hệ thống (mã nguồn hoặc môi trường) sẽ không gây ra các hiệu ứng phụ.

		- Song song với quá trình kiểm thử xác nhận (Retesting / Confirmation Testing), cũng cần kiểm thử những phần có liên quan để đảm bảo rằng  không có hiện tượng "Quýt làm cam chịu".

		- Bên cạnh đó, những thứ gì vẫn đang ổn do trước đó đã có thực hiện kiểm thử (với một bộ Test Case ổn định), thì không nên động chạm đến.
			+ Mà đã không động đến, nếu trước đó đã ổn, thì bây giờ cũng phải ổn.
			+ Nhưng mỗi khi có sự thay đổi nào đó trong mã nguồn hoặc môi trường hệ thống, đều cần phải kiểm tra lại những tính năng, mô-đun cũ... bằng cách thực thi hết tất cả các Test Case đã được thiết kế từ trước và có liên quan với những thay đổi (ví dụ: những tính năng đăng ký, đăng nhập, quên mật khẩu...).

		- Bộ Test Case vẫn sẽ giữ nguyên, ta sẽ đem chúng ra và chạy lại một lần nữa để đảm bảo mã nguồn sau khi sửa đổi cũng phải ổn giống như trước khi sửa đổi.

		- Nếu mã nguồn sau khi sửa đổi bỗng nhiên bất ổn, hoặc là tìm cách để tiếp tục cải thiện cho đến khi ổn, hoặc là sẽ bị từ chối (Reject) thẳng thừng và phải khôi phục lại (Rollback) phiên bản ổn định ban đầu.

		* Những sự thay đổi có thể là:
			- Thêm/Tích hợp-sửa-xoá tính năng.
			- Sửa lỗi code hoặc lỗi hiệu năng.
			- Yêu cầu của phần mềm (Software requirement) bị thay đổi.
			- Thay đổi môi trường hệ thống (Ví dụ: chuyển đổi Database từ MySQL sang Oracle...).
			- ...

		- Mục đích là để đảm bảo rằng những tính năng ấy vẫn hoạt động ổn định và không có lỗi mới phát sinh từ những sự thay đổi đó.

		- Thường áp dụng kiểm thử tự động (Automation Testing) và Unit Test để tự động hoá việc kiểm thử hồi quy.

		-> Xác minh để đảm bảo rằng những tính năng cũ vẫn hoạt động ổn định sau khi có thay đổi.
			(Xác minh rằng những chỉnh sửa trong mã nguồn không gây thêm lỗi.)

==========================================================================================
==========================================================================================
==========================================================================================

[03. PHÂN LOẠI THEO KỸ THUẬT / PHƯƠNG PHÁP - TESTING TECHNIQUE / METHOD]

** Kỹ thuật / Phương pháp kiểm thử (Testing Technique / Method): cách thức cụ thể để tiến hành kiểm thử, cho ra được các Test Case để xác minh (verify) kết quả mong đợi với kết quả thực tế.

==========================================================================================

	[01. KIỂM THỬ TĨNH - STATIC TESTING]

	* Kiểm thử tĩnh (Static Testing): kiểm thử mà không cần thực thi hệ thống, tìm sai sót bằng cách đọc tài liệu đặc tả yêu cầu (SRS), tài liệu thiết kế, đọc mã nguồn,... để kiểm tra về quy chuẩn lập trình,...
		- Kỹ thuật đánh giá (Review): tham khảo ý kiến của các chuyên gia.
		- Kỹ thuật phân tích tĩnh (Static Analysis): sử dụng công cụ để tự động kiểm tra quy chuẩn lập trình.

==========================================================================================

	[02. KIỂM THỬ ĐỘNG - DYNAMIC TESTING]

	* Kiểm thử động (Dynamic Testing): kiểm thử khi thực thi hệ thống để biết hệ thống xử lý đúng hay sai.

		- Kiểm thử hộp đen / dựa trên đặc tả yêu cầu (Specification Based/Behavior Based/Black-box Testing): che kín các xử lý bên trong.
			+ Kiểm thử chức năng (Functional Testing).
			+ Phi chức năng (Non-Functional Testing).

		- Kiểm thử hộp trắng (Structure Based Testing/White-box Testing): được phép xem bên trong "ruột, gan" của mã nguồn để tìm sai sót.
			+ Kiểm thử đường dẫn cơ sở (Basis Path Testing).
			+ Kiểm thử cấu trúc điều khiển (Control Structure Testing).

==========================================================================================

--------------------------------------------------------------------------------

------------------------------------------------------------

----------------------------------------

--------------------

----------













